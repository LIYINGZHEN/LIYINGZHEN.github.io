---
title:       "Go"
description: " "
date:        2019-03-16T19:00:00+00:00
author:      "Max"
published:   true
tags:        ["golang"]
categories:  ["notes"]
---

# 2.3. Zero Value

https://play.golang.org/p/yb6qYVZKYKR


# 4.2.2. In-Place Slice Techniques

https://play.golang.org/p/mO_OYvd1OIc

# 4.5. JSON

https://play.golang.org/p/Iybz_OD2fSV

# 6.2. Methods with a Pointer Receiver

In a realistic program, convention dictates that if any method of Point has a pointer receiver, then all methods of Point should have a pointer receiver, even ones that don’t strictly need it.

# 7.8. The error Interface

https://play.golang.org/p/qC0YFNckhrl

# 7.10. Type Assertions

https://play.golang.org/p/GnuwJR2FptW

# new() and make()

1. The builtin new(T) function allocates “zeroed” storage for a new item of type T and returns its address, a value of type *T.

```go
// Allocate enough memory to store a bytes.Buffer value
// and return a pointer to the value's address.
var buf bytes.Buffer
p := &buf

// Use a composite literal to perform allocation and
// return a pointer to the value's address.
p := &bytes.Buffer{}

// Use the new function to perform allocation, which will
// return a pointer to the value's address.
p := new(bytes.Buffer)
```

2. The make() function, on the other hand, is a special built-in function that is used to initialize `slices`, `maps`, and `channels`.

```go
// Using make() to initialize a map.
m := make(map[string]bool, 0)

// Using a composite literal to initialize a map.
m := map[string]bool{}
```
