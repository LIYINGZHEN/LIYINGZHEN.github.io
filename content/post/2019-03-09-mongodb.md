---
title:       "MongoDB"
description: " "
date:        2019-03-10T16:22:45+01:00
author:      "Max"
published:   true
tags:        ["mongodb"]
categories:  ["notes"]
---

# Indexing and query optimization

## Create Index

```js
db.users.createIndex(
  {
    username: 1,
    // Multikey hashed indexes aren’t allowed.
    recipe_name: "hashed"
  },
  {
    background: true,
    // In a sparse index, only those documents having some value for the indexed key will appear.
    sparse: true,
    // If you need a unique index on a collection, it’s usually best to create the index before inserting any data. If you create the index in advance, you guarantee the uniqueness constraint from the start.
    unique: true
  }
)
```

## Get Indexes

```js
db.users.getIndexes()
```

## Drop Index

```js
db.users.dropIndex("")
```

## Get in-progress operations

```js
db.currentOp()
```

## Examining slow queries

`explain()`

# Text search

- First, you define the indexes needed for text searching.
- Then, you’ll use text search in both the basic queries as well as aggregation
framework.

## Defining text search indexes

```js
db.books.createIndex(
  {
    // Specify fields to be text-indexed.
    title: "text",
    shortDescription: "text",
    longDescription: "text",
    authors: "text",
    categories: "text"
  },
  {
    // Optionally specify weights for each field.
    weights: {
      title: 10,
      shortDescription: 1,
      longDescription:1,
      authors: 1,
      categories: 5
    },
    // User-defined index name.
    name : "books_text_index"
  }
);
```

## Search:

```js
db.products.find({
  $text: { $search: "gardens" }},
  { _id: 0, name: 1, description: 1, tags:1, score: { $meta: "textScore" } })
  .sort({ score: { $meta: "textScore" } })
  .pretty()
```

```js
db.books.aggregate(
  [
    { $match: { $text: { $search: "mongodb in action" } } },
    { $project: { title: 1, score: { $meta: "textScore" } } },
    { $sort: { score: { $meta: "textScore" } } }
  ]
)
```

```js
db.books.aggregate(
  [
    { $match: { $text: { $search: "mongodb in action" } } },
    { $project: {
        title: 1,
        score: { $meta: "textScore" },
        // Calculate multiplier: 3.0 if longDescription doesn’t exist.
        multiplier: { $cond: ["$longDescription", 1.0, 3.0] } }
    },
    {
      $project: {
        _id: 0,
        title: 1,
        score: 1,
        multiplier: 1,
        // Calculate adjusted score: score * multiplier.
        adjScore: { $multiply: ["$score", "$multiplier"] }
      }
    },
    { $sort: { adjScore: -1 } }
  ]
)
```

##

```
db.books.stats()
```

# Replication

Replication provides data protection, high availability, and disaster recovery.

## Oplog

The oplog is a capped record of recent operations performed by the system, saved in the log in order to facilitate the repetition of any of those operations in the future; replicas sync via the oplog.

```bash
mongod --replSet myapp --dbpath ~/node1 --port 40000
mongod --replSet myapp --dbpath ~/node2 --port 40001
mongod --replSet myapp --dbpath ~/arbiter --port 40002
```

```bash
mongo --port 40000

rs.add("iron.local:40001")
rs.add("iron.local:40002", {arbiterOnly: true})

rs.initiate()

db.isMaster()

rs.status()
```

## Get the current replication information

```
db.getReplicationInfo()
```

## Change the default oplog size

```
mongod --replSet myapp --oplogSize 1024
```

# Sharding

## What is Sharding in MongoDB?

Sharding in MongoDB is designed to do just that: partition your database into smaller pieces so that no single machine has to store all the data or handle the entire load.

## The components of a Shard:

- Config-Server: Deployed as a replica-set, config-servers track state about which servers contain what parts of a sharded collection.

- Mongos/Router server: These servers are individual instances that do not store data locally. Instead, they query individual shards using cached state from the config-servers, as needed.

- Shard-Server: These are the MongoDB instances that actually store collection data. Shards can be deployed as standalone instances or as a replica-set (the latter is highly recommended in production!).


## Choosing a Shard Key

```bash
$ mongod --shardsvr --replSet shard-b --dbpath /data/rs-b-1 \
  --port 30100 --logpath /data/rs-b-1.log --fork
$ mongod --shardsvr --replSet shard-b --dbpath /data/rs-b-2 \
  --port 30101 --logpath /data/rs-b-2.log --fork
$ mongod --shardsvr --replSet shard-b --dbpath /data/rs-b-3 \
  --port 30102 --logpath /data/rs-b-3.log --fork
```

##

```js
sh.addShard("ServerA:27017")
sh.addShard("ServerB:27017")
```

## Enable sharding for the collection

```js
sh.enableSharding(<collection-name>)
```

## Hashing the shard key

```js
sh.shardCollection( <collection-name>, { _id: "hashed" } )
```

## Remember

1. A collection cannot be un-sharded once it has been sharded! Be sure you want to proceed before doing so.
2. You cannot change the shard-key for a sharded collection!
3. Backing up a sharded cluster is more complicated than a non-sharded cluster.
