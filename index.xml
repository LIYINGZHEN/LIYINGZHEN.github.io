<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Max Li</title>
    <link>https://www.maxlivinci.com/</link>
    <description>Recent content on Max Li</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 29 Apr 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.maxlivinci.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Stack - Next greater element in an array</title>
      <link>https://www.maxlivinci.com/algorithm/stack_next_greater_element/</link>
      <pubDate>Wed, 29 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_next_greater_element/</guid>
      <description>import java.util.Stack; public class NextGreaterElement { // Time: O(n), Space: O(n)  static void printNGE(int[] arr) { if (arr == null || arr.length == 0) { return; } int n = arr.length; Stack&amp;lt;Integer&amp;gt; s = new Stack&amp;lt;&amp;gt;(); int[] result = new int[n]; for (int i = n - 1; i &amp;gt;= 0; i--) { int data = arr[i]; if (!s.isEmpty() &amp;amp;&amp;amp; data &amp;gt; s.peek()) { s.pop(); } if (s.isEmpty()) { result[i] = -1; } else { result[i] = s.</description>
    </item>
    
    <item>
      <title>Stack - Implement two stacks in an array</title>
      <link>https://www.maxlivinci.com/algorithm/stack_implement_two_stacks_in_an_array/</link>
      <pubDate>Tue, 28 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_implement_two_stacks_in_an_array/</guid>
      <description>import java.util.Stack; public class TwoStacks { int[] array; int idx1, idx2, cap; public TwoStacks(int cap) { this.array = new int[cap]; this.idx1 = -1; this.idx2 = cap; this.cap = cap; } public boolean isFull() { return this.idx1 == this.idx2 - 1; } public void push1(int d) throws RuntimeException { if (isFull()) { throw new RuntimeException(&amp;#34;Stack Overflow&amp;#34;); } this.idx1++; this.array[this.idx1] = d; } public void push2(int d) throws RuntimeException { if (isFull()) { throw new RuntimeException(&amp;#34;Stack Overflow&amp;#34;); } this.</description>
    </item>
    
    <item>
      <title>Stack - Check for balanced parentheses</title>
      <link>https://www.maxlivinci.com/algorithm/stack_check_for_balanced_parentheses/</link>
      <pubDate>Mon, 27 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_check_for_balanced_parentheses/</guid>
      <description>import java.util.Stack; public class BalancedParen { static boolean isPair(char a, char b) { if (a == &amp;#39;(&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;)&amp;#39; || a == &amp;#39;[&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;]&amp;#39; || a == &amp;#39;{&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;}&amp;#39;) { return true; } return false; } static boolean isBalance(char[] arr) { if (arr.length == 0) { return true; } Stack&amp;lt;Character&amp;gt; temp = new Stack&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; arr.length; i++) { char data = arr[i]; if (data == &amp;#39;(&amp;#39; || data == &amp;#39;[&amp;#39; || data == &amp;#39;{&amp;#39;) { temp.</description>
    </item>
    
    <item>
      <title>Linked List - Find start of the loop</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_find_start_of_the_loop/</link>
      <pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_find_start_of_the_loop/</guid>
      <description>public class FindStartNodeInLoop{ private Node head; private static class Node { private int data; private Node next; Node(int d) { this.data = d; } } public void addToTheLast(Node node) { if (head == null) { head = node; } else { Node temp = head; while (temp.next != null) { temp = temp.next; } temp.next = node; } } public void printList() { Node temp = head; while (temp != null) { System.</description>
    </item>
    
    <item>
      <title>Linked List - Add two numbers</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_add_two_numbers/</link>
      <pubDate>Sat, 25 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_add_two_numbers/</guid>
      <description>public class AddTwoNumbers { static Node head1, head2; static class Node { int data; Node next; Node(int d) { data = d; next = null; } } int getLength(Node head) { if (head == null) { return 0; } return 1 + getLength(head.next); } void printList(Node head) { while (head != null) { System.out.print(head.data + &amp;#34; &amp;#34;); head = head.next; } System.out.println(&amp;#34;&amp;#34;); } Node reverse(final Node head) { if (head == null || head.</description>
    </item>
    
    <item>
      <title>Linked List - Reverse every alternate k nodes</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_reverse_every_alternate_k_nodes/</link>
      <pubDate>Fri, 24 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_reverse_every_alternate_k_nodes/</guid>
      <description>public class ReverseInAlternateKPair { Node head; class Node { int data; Node next; Node(int d) {data = d; next = null; } } public void push(int new_data) { Node new_node = new Node(new_data); new_node.next = head; head = new_node; } void printList() { Node temp = head; while (temp != null) { System.out.print(temp.data + &amp;#34; &amp;#34;); temp = temp.next; } System.out.println(); } Node reverse(final Node head, final int k) { if (head.</description>
    </item>
    
    <item>
      <title>Linked List - Reverse a linked list</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_reverse_a_linked_list/</link>
      <pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_reverse_a_linked_list/</guid>
      <description>public class RevertLinkedList { Node head; public class Node { int data; Node next; public Node (int d) { this.data = d; } } public void push(int data) { Node newHead = new Node(data); newHead.next = head; head = newHead; } public void printList(Node head) { if (head == null) { System.out.println(&amp;#34;null&amp;#34;); return; } System.out.printf(&amp;#34;%s -&amp;gt; &amp;#34;, head.data); printList(head.next); } // Time: O(n), Space: O(1)  public Node revertLinkedList(Node head) { if (head == null || head.</description>
    </item>
    
    <item>
      <title>Linked List - Merge sort</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_merge_sort/</link>
      <pubDate>Wed, 22 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_merge_sort/</guid>
      <description>public class MergeSort { Node head; public class Node { int data; Node next; public Node(int d) { this.data = d; } } public void printList(final Node head) { if (head == null) { System.out.println(&amp;#34;null&amp;#34;); return; } System.out.printf(&amp;#34;%s -&amp;gt; &amp;#34;, head.data); printList(head.next); } public void push(final int data) { Node newNode = new Node(data); newNode.next = head; head = newNode; } public Node merge(Node a, Node b) { if (a == null) { return b; } if (b == null) { return a; } Node newHead = null; if (a.</description>
    </item>
    
    <item>
      <title>Array - Count inversions</title>
      <link>https://www.maxlivinci.com/algorithm/array_count_inversions_in_an_array/</link>
      <pubDate>Tue, 21 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/array_count_inversions_in_an_array/</guid>
      <description>public class CountInversions { static int merge(int[] arr, int l, int h) { if (l &amp;gt;= h) { return 0; } int m = l + (h - l) / 2; int[] left = new int[m - l + 1]; int[] right = new int[h - m]; for (int i = 0; i &amp;lt; left.length; i++) { left[i] = arr[l + i]; } for (int i = 0; i &amp;lt; right.</description>
    </item>
    
    <item>
      <title>Array - Find pair in a sorted rotated array</title>
      <link>https://www.maxlivinci.com/algorithm/array_find_pair_in_a_sorted_rotated_array/</link>
      <pubDate>Mon, 20 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/array_find_pair_in_a_sorted_rotated_array/</guid>
      <description>public class PairsInSortedRotated { // Time: O(n), Space: O(1)  static void findPair(int[] arr, int target) { if (arr.length == 0) { return; } int n = arr.length; int pivot = n - 1; for (int i = 0; i &amp;lt; n - 1; i++) { if (arr[i] &amp;gt; arr[i + 1]) { pivot = i; break; } } int l = (pivot + 1) % n; int h = pivot; while (l !</description>
    </item>
    
    <item>
      <title>Array - Rotate an array</title>
      <link>https://www.maxlivinci.com/algorithm/array_rotate_an_array/</link>
      <pubDate>Sun, 19 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/array_rotate_an_array/</guid>
      <description>package array.max; import org.junit.Test; import static org.junit.Assert.assertArrayEquals; public class RotateArray { // Time: O(n), Space: O(1)  static void rotateArr(int arr[], int d) { if (arr.length == 0) { return; } int n = arr.length; int step = d % arr.length; int count = 0; for (int start = 0; count &amp;lt; n; start++) { int curr = start; int prev = arr[curr]; do { int next = (curr + n - step) % n; int temp = arr[next]; arr[next] = prev; prev = temp; curr = next; count++; } while (start !</description>
    </item>
    
    <item>
      <title>Array - Trapping rain water</title>
      <link>https://www.maxlivinci.com/algorithm/array_trapping_rain_water/</link>
      <pubDate>Sat, 18 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/array_trapping_rain_water/</guid>
      <description>package array.max; import org.junit.Test; import static org.junit.Assert.assertEquals; public class TrappingRainWater { static int maxWater(int[] arr) { if (arr.length == 0) { return 0; } int n = arr.length; int leftMax = Integer.MIN_VALUE, rightMax = Integer.MIN_VALUE; int l = 0, h = n - 1; int trap = 0; while (l &amp;lt; h) { if (arr[l] &amp;lt; arr[h]) { if (arr[l] &amp;gt; leftMax) { leftMax = arr[l]; } else { trap += leftMax - arr[l]; } l++; } else { if (arr[h] &amp;gt; rightMax) { rightMax = arr[l]; } else { trap += rightMax - arr[h]; } h--; } } return trap; } @Test public void test() { assertEquals(2, maxWater(new int[]{2, 0, 2})); assertEquals(7, maxWater(new int[]{3, 0, 2, 0, 4})); assertEquals(6, maxWater(new int[]{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1})); } } </description>
    </item>
    
    <item>
      <title>Array - Maximum index</title>
      <link>https://www.maxlivinci.com/algorithm/array_maximum_index/</link>
      <pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/array_maximum_index/</guid>
      <description>Given an array arr[], find the maximum j – i such that arr[j] &amp;gt; arr[i]
package array.max; import org.junit.Test; import static org.junit.Assert.assertEquals; public class MaximumIndex { // Time: O(n) ; Space: O(n)  static int maximun(int[] arr) { if (arr.length == 0) { return -1; } int n = arr.length; int[] maxFromTheRight = new int[n]; int max = Integer.MIN_VALUE; for (int i = n - 1; i &amp;gt;= 0; i--) { int num = arr[i]; if (num &amp;gt; max) { max = num; } maxFromTheRight[i] = max; } int i = 0, j = 0, maxDiff = -1; while (i &amp;lt; n &amp;amp;&amp;amp; j &amp;lt; n) { int num = arr[i]; if (num &amp;lt; maxFromTheRight[j]) { maxDiff = Math.</description>
    </item>
    
    <item>
      <title>Sorting - Merge sort</title>
      <link>https://www.maxlivinci.com/algorithm/sorting_merge_sort/</link>
      <pubDate>Thu, 16 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/sorting_merge_sort/</guid>
      <description>import java.util.Arrays; public class MergeSort { public static void merge(int[] arr, int l, int h) { if (l &amp;gt;= h) { return; } int m = l + (h - l) / 2; int[] leftCopy = new int[m - l + 1]; int[] rightCopy = new int[h - m]; for (int i = 0; i &amp;lt; leftCopy.length; i++) { leftCopy[i] = arr[l + i]; } for (int i = 0; i &amp;lt; rightCopy.</description>
    </item>
    
    <item>
      <title>Sorting - Sort an array of 0s, 1s and 2s</title>
      <link>https://www.maxlivinci.com/algorithm/sorting_sort_an_array_of_012/</link>
      <pubDate>Wed, 15 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/sorting_sort_an_array_of_012/</guid>
      <description>public class Sort012 { static void swap(int[] arr, int a, int b) { int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; } static void sort012(int[] arr) { if (arr.length == 0) { return; } int i = 0, j = 0, k = arr.length - 1; while (j &amp;lt;= k) { if (arr[j] == 0) { swap(arr, i, j); i++; j++; } else if (arr[j] == 1) { j++; } else if (arr[j] == 2) { swap(arr, j, k); k--; } } } static void printArray(int[] arr) { if (arr.</description>
    </item>
    
    <item>
      <title>Sorting - Count inversions</title>
      <link>https://www.maxlivinci.com/algorithm/sorting_count_inversions/</link>
      <pubDate>Tue, 14 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/sorting_count_inversions/</guid>
      <description>import org.junit.Test; import static org.junit.Assert.assertEquals; public class InversionOfArray { static int merge(int[] arr, int l, int h) { int m = l + (h - l) / 2; int[] leftCopy = new int[m - l + 1]; int[] rightCopy = new int[h - m]; for (int i = 0; i &amp;lt; leftCopy.length; i++) { leftCopy[i] = arr[l + i]; } for (int i = 0; i &amp;lt; rightCopy.length; i++) { rightCopy[i] = arr[m + 1 + i]; } int i = 0, j = 0, k = l, count = 0; while (i &amp;lt; leftCopy.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://www.maxlivinci.com/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/about/</guid>
      <description>Hi there!</description>
    </item>
    
  </channel>
</rss>