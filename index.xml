<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>YING ZHEN LI</title>
    <link>https://www.maxlivinci.com/</link>
    <description>Recent content on YING ZHEN LI</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 01 Jun 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.maxlivinci.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LeetCode - Merge Two Sorted Lists</title>
      <link>https://www.maxlivinci.com/blog/2019-06-01-leetcode-merge-two-sorted-lists/</link>
      <pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-06-01-leetcode-merge-two-sorted-lists/</guid>
      <description>LeetCode
Problem Statement Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
Example
 Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4
Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4
 Solution /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { // Check boundary condition if l1 == nil { return l2 } if l2 == nil { return l1 } // Create dummy node dummy := ListNode{} head := &amp;amp;dummy // Connect l1 and l2 for l1 !</description>
    </item>
    
    <item>
      <title>LeetCode - Rotate Array</title>
      <link>https://www.maxlivinci.com/blog/2019-05-31-leetcode-rotate-array/</link>
      <pubDate>Fri, 31 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-31-leetcode-rotate-array/</guid>
      <description>LeetCode
Problem Statement Given an array, rotate the array to the right by k steps, where k is non-negative.
Example 1
 Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4]
 Example 2
 Input: [-1,-100,3,99] and k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100]</description>
    </item>
    
    <item>
      <title>LeetCode - Remove Duplicates from Sorted Array</title>
      <link>https://www.maxlivinci.com/blog/2019-05-30-leetcode-remove-duplicates-from-sorted-array/</link>
      <pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-30-leetcode-remove-duplicates-from-sorted-array/</guid>
      <description>LeetCode
Problem Statement Given a sorted array of numbers, remove the duplicates in-place such that each element appear only once and return the new length.
Example 1
&amp;gt; Given nums = [1,1,2], &amp;gt; &amp;gt; Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. &amp;gt; &amp;gt; It doesn’t matter what you leave beyond the returned length. *Example 2* &amp;gt; Given nums = [0,0,1,1,1,2,2,3,3,4], &amp;gt; &amp;gt; Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</description>
    </item>
    
    <item>
      <title>How to end a goroutine</title>
      <link>https://www.maxlivinci.com/blog/2019-05-24-how-to-end-a-goroutine/</link>
      <pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-24-how-to-end-a-goroutine/</guid>
      <description>1. Stop Channel package main import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; ) func main() { ch := make(chan int) done := make(chan struct{}) go func() { i := 0 for { select { case ch &amp;lt;- i: i++ case &amp;lt;-done: close(ch) return } time.Sleep(100 * time.Millisecond) } }() go func() { time.Sleep(3 * time.Second) done &amp;lt;- struct{}{} }() for i := range ch { fmt.Println(&amp;quot;receive value: &amp;quot;, i) } fmt.Println(&amp;quot;finish&amp;quot;) }  2.</description>
    </item>
    
    <item>
      <title>Types in Go</title>
      <link>https://www.maxlivinci.com/blog/2019-05-22-types-in-go/</link>
      <pubDate>Wed, 22 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-22-types-in-go/</guid>
      <description>Terminology  Pre-Declared Type Composite Type (Type Literal) Named Type Unnamed Types Underlying Type Assignability Type Conversions Untyped constants Default Type  Pre-Declared Type Part of Named Type.
String Integer Boolean  Composite Type (Type Literal) Part of Unnamed Types.
Array Slice Map Struct  Named Type Named types can have their own method sets.
  Unnamed Types  Underlying Type Every type do have an underlying type. Pre-declared types and Composite Type refers to itself as the underlying type.</description>
    </item>
    
    <item>
      <title>Factory patterns in Go</title>
      <link>https://www.maxlivinci.com/blog/2019-05-17-factory-patterns-in-go/</link>
      <pubDate>Fri, 17 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-17-factory-patterns-in-go/</guid>
      <description>The factory pattern is a commonly used pattern in object oriented programming. In Go, there are many different ways in which you can use the factory pattern to make your code cleaner and more concise.
Go’s answer to classes, are structs. For example, the struct for a “Person”, along with a “Greet” method would look like this:
type Greeter interface { Greet() } type Person struct { Name string Age int } func (p Person) Greet() { fmt.</description>
    </item>
    
    <item>
      <title>Go Rune</title>
      <link>https://www.maxlivinci.com/blog/2019-05-16-go-rune/</link>
      <pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-16-go-rune/</guid>
      <description>package main import &amp;quot;fmt&amp;quot; func main() { var chinese = &amp;quot;人工智能&amp;quot; fmt.Println(&amp;quot;chinese length&amp;quot;, len(chinese)) fmt.Println(&amp;quot;chinese word length&amp;quot;, len([]rune(chinese))) fmt.Println(&amp;quot;chinese word length&amp;quot;, utf8.RuneCountInString(chinese)) for i, ch := range chinese { fmt.Printf(&amp;quot;(%d, %c)&amp;quot;, i, ch) // (0, 人)(3, 工)(6, 智)(9, 能) } fmt.Println() for i, ch := range []rune(chinese) { fmt.Printf(&amp;quot;(%d, %c)&amp;quot;, i, ch) // (0, 人)(1, 工)(2, 智)(3, 能) } fmt.Println() }  # chinses is 3 bytes chinese length 12 chinese word length 4 chinese word length 4 (0, 人)(3, 工)(6, 智)(9, 能) (0, 人)(1, 工)(2, 智)(3, 能)  </description>
    </item>
    
    <item>
      <title>Docker Cheat Sheet</title>
      <link>https://www.maxlivinci.com/blog/2019-05-14-docker-cheat-sheet/</link>
      <pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-14-docker-cheat-sheet/</guid>
      <description>Docker Container List all containers
docker ps -a # include stopped -q # only returns the container IDs  Run a shell inside an existing container
docker exec -it # connect the container to terminal &amp;lt;container&amp;gt; &amp;lt;command&amp;gt; # bin/sh, bin/bash  Starting a stopped container
docker start &amp;lt;container&amp;gt;  Print a container’s logs docker logs -f # tail -t # timestamps &amp;lt;container&amp;gt;  Restarting a stopped container
docker restart &amp;lt;container&amp;gt;  Getting additional information about a container</description>
    </item>
    
    <item>
      <title>Docker Compose Cheat Sheet</title>
      <link>https://www.maxlivinci.com/blog/2019-05-14-docker-compose-cheat-sheet/</link>
      <pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-14-docker-compose-cheat-sheet/</guid>
      <description>docker-compose.yml version: &amp;quot;3&amp;quot; services: voting-app: build: ./voting-app/. # bind mount volumes: - ./voting-app:/app ports: - &amp;quot;5000:80&amp;quot; links: - redis networks: - front-tier - back-tier result-app: build: ./result-app/. # bind mount volumes: - ./result-app:/app ports: - &amp;quot;5001:80&amp;quot; links: - db networks: - front-tier - back-tier worker: build: ./worker links: - db - redis networks: - back-tier redis: image: redis ports: [&amp;quot;6379&amp;quot;] networks: - back-tier db: image: postgres:9.4 # docker volume volumes: - &amp;quot;db-data:/var/lib/postgresql/data&amp;quot; networks: - back-tier volumes: db-data: networks: front-tier: driver: bridge back-tier: driver: bridge  Commands docker-compose -f &amp;lt;docker-compose.</description>
    </item>
    
    <item>
      <title>Atomic Counters</title>
      <link>https://www.maxlivinci.com/blog/2019-05-12-atomic-counters/</link>
      <pubDate>Sun, 12 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-12-atomic-counters/</guid>
      <description>Program with the the race condition package main import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; ) func main() { var ops uint64 for i := 0; i &amp;lt; 10000; i++ { go func() { ops = ops + 1 }() } time.Sleep(time.Second) fmt.Println(&amp;quot;ops:&amp;quot;, ops) }  ops: 9742  Solving the race condition using Mutex package main import ( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; &amp;quot;time&amp;quot; ) func main() { var ops uint64 var m sync.Mutex for i := 0; i &amp;lt; 10000; i++ { go func() { m.</description>
    </item>
    
    <item>
      <title>Build a Web Crawler in Go</title>
      <link>https://www.maxlivinci.com/blog/2019-05-11-build-a-web-crawler-in-go/</link>
      <pubDate>Sat, 11 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-11-build-a-web-crawler-in-go/</guid>
      <description>package main import ( &amp;quot;crypto/tls&amp;quot; &amp;quot;flag&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;net/url&amp;quot; &amp;quot;os&amp;quot; &amp;quot;github.com/jackdanger/collectlinks&amp;quot; ) var visited = make(map[string]bool) func main() { // Parses the command-line flags. flag.Parse() args := flag.Args() fmt.Println(args) if len(args) &amp;lt; 1 { fmt.Println(&amp;quot;Please specify start page&amp;quot;) os.Exit(1) } queue := make(chan string) go func() { queue &amp;lt;- args[0] }() for uri := range queue { enqueue(uri, queue) } } func enqueue(uri string, queue chan string) { fmt.Println(&amp;quot;fetching&amp;quot;, uri) visited[uri] = true transport := &amp;amp;http.</description>
    </item>
    
    <item>
      <title>Functional options</title>
      <link>https://www.maxlivinci.com/blog/2019-05-10-functional-options/</link>
      <pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-10-functional-options/</guid>
      <description>Here&amp;rsquo;s the simplest example showing how to do functional options in Golang.
They&amp;rsquo;re a great way to enable users to set options and ease adding new options later.
package main import ( &amp;quot;flag&amp;quot; &amp;quot;fmt&amp;quot; ) // This is your function used by users to set options. func Host(host string) func(*Server) { return func(s *Server) { s.Host = host } } // This is another function used by users to set options.</description>
    </item>
    
    <item>
      <title>Data races in Go</title>
      <link>https://www.maxlivinci.com/blog/2019-05-09-data-races-in-go/</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-09-data-races-in-go/</guid>
      <description>Go is known for how easy it is to build concurrent programs in it. But, with all this concurrency, comes the possibility of the dreaded data race — one of the hardest bugs to debug if you’re ever unfortunate enough to encounter it in your code.
In this post, we will go through a sample program that causes a data race, and detect the race condition with the race detector tool.</description>
    </item>
    
    <item>
      <title>Standard Package Layout</title>
      <link>https://www.maxlivinci.com/blog/2019-05-08-standard-package-layout/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-08-standard-package-layout/</guid>
      <description>myapp/ cmd/ server/ main.go /internal http/ middleware.go middleware_test.go route.go server.go userhandler.go psql/ psql.go userrepository.go service/ userservice/ userservice.go userservice_test.go # Domain types models.go  Domain types Your application has a logical, high-level language that describes how data and processes interact. This is your domain. If you have an e-commerce application your domain involves things like customers, accounts, charging credit cards, and handling inventory. If you’re Facebook then your domain is users, likes, &amp;amp; relationships.</description>
    </item>
    
    <item>
      <title>Password Hashing</title>
      <link>https://www.maxlivinci.com/blog/2019-05-07-password-hashing/</link>
      <pubDate>Tue, 07 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-07-password-hashing/</guid>
      <description>This example will show how to hash passwords using bcrypt. For this we have to go get the golang bcrypt library like so:
$ go get golang.org/x/crypto/bcrypt  From now on, every application we write will be able to make use of this library.
// passwords.go package main import ( &amp;quot;fmt&amp;quot; &amp;quot;golang.org/x/crypto/bcrypt&amp;quot; ) func HashPassword(password string) (string, error) { bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14) return string(bytes), err } func CheckPasswordHash(password, hash string) bool { err := bcrypt.</description>
    </item>
    
    <item>
      <title>Go Memory Layout</title>
      <link>https://www.maxlivinci.com/blog/2019-05-06-go-memory-layout/</link>
      <pubDate>Mon, 06 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-06-go-memory-layout/</guid>
      <description>How memory works internally When you have a struct like this one:
type myStruct struct { myInt bool // 1 byte myFloat float64 // 8 bytes myBool int32 // 4 bytes }  As you see a boolean takes 1 byte, a float64 8 bytes, and an int32 4 bytes.
But the memory allocates consecutive packet of 8 bytes. So instead of taking 1 + 8 + 4 = 13 bytes.</description>
    </item>
    
    <item>
      <title>Go Escape Analysis</title>
      <link>https://www.maxlivinci.com/blog/2019-05-05-go-escape-analysis/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-05-go-escape-analysis/</guid>
      <description>Garbage collection is a convenient feature of Go - automatic memory management makes code cleaner and memory leaks less likely. However, GC also adds overhead as the program periodically needs to stop and collect unused objects. The Go compiler is smart enough to automatically decide whether a variable should be allocated on the heap, where it will later need to be garbage collected, or whether it can be allocated as part of the stack frame of the function which declared it.</description>
    </item>
    
    <item>
      <title>Go Command link</title>
      <link>https://www.maxlivinci.com/blog/2019-05-04-go-command-link/</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-04-go-command-link/</guid>
      <description>The -X Go linker option, which you can set with -ldflags, sets the value of a string variable in the Go program being linked. You use it like this: -X main.version 1.0.0.
A simple example: let&amp;rsquo;s say you have this source file saved as hello.go.
package main import &amp;quot;fmt&amp;quot; var who = &amp;quot;World&amp;quot; func main() { fmt.Printf(&amp;quot;Hello, %s.\n&amp;quot;, who) }  Then you can use go run (or other build commands like go build or go install) with the -ldflags option to modify the value of the who variable:</description>
    </item>
    
    <item>
      <title>The Relationship Between Interfaces and Reflection</title>
      <link>https://www.maxlivinci.com/blog/2019-05-03-the-relationship-between-interfaces-and-reflection/</link>
      <pubDate>Fri, 03 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-03-the-relationship-between-interfaces-and-reflection/</guid>
      <description>Interfaces are one of the fundamental tools for abstraction in Go. Interfaces store type information when assigned a value. Reflection is a method of examining type and value information at runtime.
Go implements reflection with the reflect package which provides types and methods for inspecting portions of the interface structure and even modifying values at runtime.
Assigning a Value to an Interface An interface encodes three things: a value, a method set, and the type of the stored value.</description>
    </item>
    
    <item>
      <title>Interfaces in Go</title>
      <link>https://www.maxlivinci.com/blog/2019-05-02-interfaces-in-go/</link>
      <pubDate>Thu, 02 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-02-interfaces-in-go/</guid>
      <description>An interface type is defined by a set of methods. A value of interface type can hold any value that implements those methods.
Go&amp;rsquo;s interfaces let you use duck typing.
Static Type V.S. Dynamic Type V.S. Dynamic Value  Static Type: A static type of interface is interface itself. Dynamic Type: The type of the value which the interface type holds. Dynamic Value: The value of the value which the interface type holds.</description>
    </item>
    
    <item>
      <title>Go Context</title>
      <link>https://www.maxlivinci.com/blog/2019-05-01-go-context/</link>
      <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-01-go-context/</guid>
      <description>There are two classical way to control concurrent, one is WaitGroup another way is Context. And today we are going to talk about Context.
Using Channel package main import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; ) func monitor(stop chan struct{}) &amp;lt;-chan string { ch := make(chan string) go func() { for { select { case &amp;lt;-stop: close(ch) return case &amp;lt;-time.Tick(1 * time.Second): ch &amp;lt;- &amp;quot;Status OK&amp;quot; } } }() return ch } func main() { stop := make(chan struct{}) go func() { time.</description>
    </item>
    
    <item>
      <title>Update map values in Go</title>
      <link>https://www.maxlivinci.com/blog/2019-04-30-update-map-values-in-go/</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-30-update-map-values-in-go/</guid>
      <description>We can&amp;rsquo;t change values associated with keys in a map, we can only reassign values.
So this leaves us 2 possible options:
 1. Store pointers in the map, so you can modify the pointed object (which is not inside the map data structure). 2. Store struct values, but when you modify it, you need to reassign it to the key.  1. Using pointers Storing pointers in the map: dataManaged := map[string]*Data{}</description>
    </item>
    
    <item>
      <title>Pass by pointer vs pass by value in Go</title>
      <link>https://www.maxlivinci.com/blog/2019-04-29-pass-by-pointer-vs-pass-by-value-in-go/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-29-pass-by-pointer-vs-pass-by-value-in-go/</guid>
      <description>Go allows to pass parameters both by pointers (sometimes it’s called by reference) and by values. In this post we will compare both approaches, paying special attention to different contexts that may affect the choice.
Pass by pointer vs pass by value Strictly speaking, there is only one way to pass parameters in Go - by value. Every time a variable is passed as parameter, a new copy of the variable is created and passed to called function or method.</description>
    </item>
    
    <item>
      <title>Go Tooling Essentials</title>
      <link>https://www.maxlivinci.com/blog/2019-04-28-go-tooling-essentials/</link>
      <pubDate>Sun, 28 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-28-go-tooling-essentials/</guid>
      <description>New to the Go tools? Or do you want to expand your knowledge? This article is about the flags for the Go tools everyone should know.
$ go test -v It provides chatty output for the testing. It prints the test name, its status (failed or passed), how much it took to run the test, any logs from the test case, etc.
go test without the -v flag is highly quiet, I always use it with -v turned on.</description>
    </item>
    
    <item>
      <title>Unit Testing HTTP Servers</title>
      <link>https://www.maxlivinci.com/blog/2019-04-27-unit-testing-http-servers/</link>
      <pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-27-unit-testing-http-servers/</guid>
      <description>You’re building a web (HTTP) service in Go, and you want to unit test your handler functions. You’ve got a grip on Go’s net/http package, but you’re not sure where to start with testing that your handlers return the correct HTTP status codes, HTTP headers or response bodies.
Let’s walk through how you go about this, injecting the necessary dependencies, and mocking the rest.
A Basic Handler We’ll start by writing a basic test: we want to make sure our handler returns a HTTP 200 (OK) status code.</description>
    </item>
    
    <item>
      <title>JSON and Go</title>
      <link>https://www.maxlivinci.com/blog/2019-04-26-json-and-go/</link>
      <pubDate>Fri, 26 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-26-json-and-go/</guid>
      <description>Parsing a format like JSON in a statically typed language like Go presents a bit of a problem. If anything could show up in the JSON body, how does the compiler know how to setup memory to have a spot to place everything?
There are two answers to this. The easy option, for when you know what your data will look like, is to parse the JSON into a struct you’ve defined.</description>
    </item>
    
    <item>
      <title>Efficient String Concatenation in Go</title>
      <link>https://www.maxlivinci.com/blog/2019-04-25-efficient-string-concatenation-in-go/</link>
      <pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-25-efficient-string-concatenation-in-go/</guid>
      <description>In this article I investigate the computational performance of various string concatenation methods in the Go programming language.
To evaluate the options, I prepared some typical Go benchmarks using the Go testing package. A benchmark looks something like this:
func BenchmarkNative(b *testing.B) { var s string next := nextString() for i := 0; i &amp;lt; b.N; i++ { s += next() } }  For the purposes of these benchmarks, I imagined having a process that returns string segments one by one, and these segments need to be concatenated to form one string.</description>
    </item>
    
    <item>
      <title>Writing middleware in Golang</title>
      <link>https://www.maxlivinci.com/blog/2019-04-24-writing-middleware-in-golang/</link>
      <pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-24-writing-middleware-in-golang/</guid>
      <description>When we talk about Middleware in Go, at its simplest, we are really talking about running code before and/or after our handler code in a HTTP request lifecycle. For example, logging middleware might write the incoming request details to a log, then call the handler code, before writing details about the response to the log. One of the cool things about middleware, if implemented correctly, is that these units are extremely flexible, reusable, and sharable.</description>
    </item>
    
    <item>
      <title>Working with Files in Go</title>
      <link>https://www.maxlivinci.com/blog/2019-04-23-working-with-files-in-go/</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-23-working-with-files-in-go/</guid>
      <description>One of the fundamental aspects of UNIX is that everything is a file. We don&amp;rsquo;t necessarily know what the file descriptor maps to, that is abstracted by the operating system&amp;rsquo;s device drivers. The operating system provides us an interface to the device in the form of a file.
The reader and writer interfaces in Go are similar abstractions. We simply read and write bytes, without the need to understand where or how the reader gets its data or where the writer is sending the data.</description>
    </item>
    
    <item>
      <title>Slices from the ground up</title>
      <link>https://www.maxlivinci.com/blog/2019-04-22-slices-from-the-ground-up/</link>
      <pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-22-slices-from-the-ground-up/</guid>
      <description>Arrays Arrays in Go have two relevant properties:
 They have a fixed size; [5]int is is distinct from [3]int. They are value types. Consider this example:  package main import &amp;quot;fmt&amp;quot; func main() { var a [5]int b := a b[2] = 7 fmt.Println(a, b) // prints [0 0 0 0 0] [0 0 7 0 0] }  The statement b := a declares a new variable, b, of type [5]int, and copies the contents of a to b.</description>
    </item>
    
    <item>
      <title>Gopher Reading List</title>
      <link>https://www.maxlivinci.com/blog/2019-04-21-gopher-reading-list/</link>
      <pubDate>Sun, 21 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-21-gopher-reading-list/</guid>
      <description>Here is a reading list of blog posts about Go. It aspires to include only the most useful and relevant material that anyone writing Go should eventually read. By definition, the list is a work in progress.
Rather than being comprehensive, the list is a curated selection fixed at 200 entries.
Go is growing fast and so are the number of blog posts about it. If an interested reader knows of a great post not on this list, please open an issue with a link to the post.</description>
    </item>
    
    <item>
      <title>Building a website</title>
      <link>https://www.maxlivinci.com/blog/2019-04-20-building-a-website/</link>
      <pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-20-building-a-website/</guid>
      <description>Since I started programming, I’ve found myself interested in many subjects and technologies. However, despite a few efforts, I never managed to get interested in front-end development.
I have tried several frameworks: Bootstrap, React, and a few more. I admit I enjoy way more developing something with React than doing plain HTML/CSS/JS, but let’s face it, it’s just not my cup of tea. Sometimes I have to work on front-end projects, but whenever I can avoid it, I do it.</description>
    </item>
    
    <item>
      <title>Linux</title>
      <link>https://www.maxlivinci.com/old/2019-03-14-linux/</link>
      <pubDate>Thu, 14 Mar 2019 07:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-03-14-linux/</guid>
      <description> Commands ls -l # Changes the working directory to your home directory. cd # Changes the working directory to the previous working directory. cd - # i - interactive # v - verbose cp -iv /etc/passwd . # i - interactive # r - recursive rm -ir fun  </description>
    </item>
    
    <item>
      <title>Redis</title>
      <link>https://www.maxlivinci.com/old/2019-03-13-redis/</link>
      <pubDate>Wed, 13 Mar 2019 06:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-03-13-redis/</guid>
      <description>Commands redis-cli # Local redis-cli -h host -p port -a password # Run Commands on the Remote Server redis-cli INFO memory  Data Types  Strings Lists Hashes Sets Sorted Sets  Strings # SET first &amp;quot;First Key value&amp;quot; GET first # EXPIRE command adds an expiration time (in seconds) to a given key. EXPIRE first 10 # TTL (Time To Live) command returns the amount of seconds a given key has left to live.</description>
    </item>
    
    <item>
      <title>MongoDB</title>
      <link>https://www.maxlivinci.com/old/2019-03-09-mongodb/</link>
      <pubDate>Sun, 10 Mar 2019 16:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-03-09-mongodb/</guid>
      <description>Indexing and query optimization  Indexes in MongoDB are very important. Indexes that use more than one key like this are called compound indexes. The order of keys in a compound index matters. Aa query where one term demands an exact match and another specifies a range requires a compound index where the range key comes second.  For example:
If we have this query, then the manufacturer shoud be the first index.</description>
    </item>
    
    <item>
      <title>OpenAPI Specification</title>
      <link>https://www.maxlivinci.com/old/2019-01-26-open-api-specification/</link>
      <pubDate>Sat, 26 Jan 2019 18:40:48 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-26-open-api-specification/</guid>
      <description>OpenAPI lets us define RESTful APIs in a standardized manner, and they can be defined without being tied down to any particular programming language or framework being used.
Let&amp;rsquo;s list the general structure of an OpenAPI specification and use it to redefine the Books API described in Chapter 4, The RESTful Web.
If we look at the Books API title, we can define the following elements to describe the API:</description>
    </item>
    
    <item>
      <title>Go Environment</title>
      <link>https://www.maxlivinci.com/old/2019-01-26-go-environment/</link>
      <pubDate>Sat, 26 Jan 2019 11:20:00 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-26-go-environment/</guid>
      <description>GOROOT To access to the Go binary and its libraries
GOPATH To tell the Go compiler where to find the source code for the project and its dependencies.
src/ Contain the source code of our projects and their dependencies.
pkg/ To store reusable machine code that can be readily included in our Go binary.
bin/ Go compiles and builds our projects into executable binaries and places them in this directory.</description>
    </item>
    
    <item>
      <title>Worker pools</title>
      <link>https://www.maxlivinci.com/old/2019-01-26-worker-pools/</link>
      <pubDate>Sat, 26 Jan 2019 09:52:00 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-26-worker-pools/</guid>
      <description>A worker pool is a set of threads that are about to process jobs assigned to them.  Example package main import ( &amp;quot;fmt&amp;quot; &amp;quot;os&amp;quot; &amp;quot;strconv&amp;quot; &amp;quot;sync&amp;quot; &amp;quot;time&amp;quot; ) type Client struct { id int integer int } type Data struct { job Client square int } var ( size = 10 clients = make(chan Client, size) data = make(chan Data, size) ) func worker(w *sync.WaitGroup) { for c := range clients { square := c.</description>
    </item>
    
    <item>
      <title>Concurrency and parallelism</title>
      <link>https://www.maxlivinci.com/old/2019-01-25-concurrency-and-parallelism/</link>
      <pubDate>Fri, 25 Jan 2019 21:08:00 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-25-concurrency-and-parallelism/</guid>
      <description>Computer and software programs are useful because they do a lot of laborious work very fast and can also do multiple things at once. We want our programs to be able to do multiple things simultaneously, that is, multitask, and the success of a programming language can depend on how easy it is to write and understand multitasking programs.
Concurrency and parallelism are two terms that we are bound to come across often when looking into multitasking and they are often used interchangeably.</description>
    </item>
    
    <item>
      <title>General Go coding advices</title>
      <link>https://www.maxlivinci.com/old/2019-01-19-general-go-coding-advices/</link>
      <pubDate>Sat, 19 Jan 2019 17:05:00 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-19-general-go-coding-advices/</guid>
      <description>The following list offers practical advices that will help you write better Go code:
 If you have an error in a Go function, either log it or return it, do not do both unless you have a really good reason for doing so! Go interfaces define behaviors, not data and data structures. Use the io.Reader and io.Writer interfaces because they make your code more extensible. Make sure that you pass a pointer to a variable of a function only when needed.</description>
    </item>
    
    <item>
      <title>Find out Go Environment</title>
      <link>https://www.maxlivinci.com/old/2019-01-19-find-out-go-environment/</link>
      <pubDate>Sat, 19 Jan 2019 17:02:00 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-19-find-out-go-environment/</guid>
      <description>package main import ( &amp;quot;fmt&amp;quot; &amp;quot;runtime&amp;quot; ) func main() { fmt.Print(&amp;quot;You are using &amp;quot;, runtime.Compiler, &amp;quot; &amp;quot;) fmt.Println(&amp;quot;on a&amp;quot;, runtime.GOARCH, &amp;quot;machine&amp;quot;) fmt.Println(&amp;quot;Using Go version&amp;quot;, runtime.Version()) fmt.Println(&amp;quot;Number of CPUs:&amp;quot;, runtime.NumCPU()) fmt.Println(&amp;quot;Number of Goroutines:&amp;quot;, runtime.NumGoroutine()) }  xecuting goEnv.go on a macOS High Sierra machine with Go version 1.9.2 will create the following output:
$ go run goEnv.go You are using gc on a amd64 machine Using Go version go1.9.2 Number of CPUs: 8 Number of Goroutines: 1  </description>
    </item>
    
    <item>
      <title>Writing to log files</title>
      <link>https://www.maxlivinci.com/old/2019-01-19-writing-to-log-files/</link>
      <pubDate>Sat, 19 Jan 2019 15:44:00 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-19-writing-to-log-files/</guid>
      <description>Generally speaking, using a log file to write some information is considered a better practice than writing the same output on the screen for two reasons:
 The output does not get lost as it is stored in a file
 You can search and process log files using Unix tools such as grep(1), awk(1), and sed(1), which cannot be done when messages are printed on a Terminal window</description>
    </item>
    
    <item>
      <title>An Example of Using RabbitMQ From Go</title>
      <link>https://www.maxlivinci.com/old/2019-01-19-an-example-of-using-rabbitmq-from-go/</link>
      <pubDate>Sat, 19 Jan 2019 07:42:05 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-19-an-example-of-using-rabbitmq-from-go/</guid>
      <description>Sending We&amp;rsquo;ll call our message publisher (sender) send.go and our message consumer (receiver) receive.go. The publisher will connect to RabbitMQ, send a single message, then exit.
package main import ( &amp;quot;log&amp;quot; &amp;quot;github.com/streadway/amqp&amp;quot; ) func failOnError(err error, msg string) { if err != nil { log.Fatalf(&amp;quot;%s: %s&amp;quot;, msg, err) } } func main() { conn, err := amqp.Dial(&amp;quot;amqp://guest:guest@localhost:5672/&amp;quot;) failOnError(err, &amp;quot;Failed to connect to RabbitMQ&amp;quot;) defer conn.Close() ch, err := conn.Channel() failOnError(err, &amp;quot;Failed to open a channel&amp;quot;) defer ch.</description>
    </item>
    
    <item>
      <title>CQRS</title>
      <link>https://www.maxlivinci.com/old/2019-01-19-cqrs/</link>
      <pubDate>Sat, 19 Jan 2019 07:00:00 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-19-cqrs/</guid>
      <description>Introducing Command Query Responsibility Segregation CQRS is a fancy pattern name that means decoupling the input and the output of your system.</description>
    </item>
    
    <item>
      <title>Event-Driven Architecture</title>
      <link>https://www.maxlivinci.com/old/2019-01-13-event-driven-architecture/</link>
      <pubDate>Sun, 13 Jan 2019 13:44:00 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-13-event-driven-architecture/</guid>
      <description>Asynchronous processing With asynchronous processing, all the communication to the downstream application happens out of process leveraging a queue or a message broker as an intermediary.</description>
    </item>
    
    <item>
      <title>Serving Static Files In Go</title>
      <link>https://www.maxlivinci.com/old/2019-01-12-servering-static-files/</link>
      <pubDate>Sat, 12 Jan 2019 17:15:17 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-12-servering-static-files/</guid>
      <description>func main() { port := 8080 cathandler := http.FileServer(http.Dir(&amp;quot;./images&amp;quot;)) // images/... http.Handle(&amp;quot;/cat/&amp;quot;, http.StripPrefix(&amp;quot;/cat/&amp;quot;, cathandler)) // images/cat/... http.Handle(&amp;quot;/cat/&amp;quot;, cathandler) log.Printf(&amp;quot;Server starting on port %v\n&amp;quot;, 8080) log.Fatal(http.ListenAndServe(fmt.Sprintf(&amp;quot;:%v&amp;quot;, port), nil)) }  </description>
    </item>
    
    <item>
      <title>An Example of Using Nsq From Go</title>
      <link>https://www.maxlivinci.com/old/2019-01-11-an-example-of-using-nsq-from-go/</link>
      <pubDate>Fri, 11 Jan 2019 10:27:05 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-11-an-example-of-using-nsq-from-go/</guid>
      <description>NSQ is a message queue, similar to RabbitMQ. I decided I’d give it a whirl.
Install Nsq brew install nsq  Launch Nsq nsqlookupd &amp;amp; nsqd --lookupd-tcp-address=127.0.0.1:4160 &amp;amp; nsqadmin --lookupd-http-address=127.0.0.1:4161 &amp;amp;  Get Go client library go get github.com/nsqio/go-nsq  Create a producer package main import ( &amp;quot;log&amp;quot; &amp;quot;github.com/bitly/go-nsq&amp;quot; ) func main() { config := nsq.NewConfig() w, _ := nsq.NewProducer(&amp;quot;127.0.0.1:4150&amp;quot;, config) err := w.Publish(&amp;quot;write_test&amp;quot;, []byte(&amp;quot;test&amp;quot;)) if err != nil { log.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://www.maxlivinci.com/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/about/</guid>
      <description>Hey, I&amp;rsquo;m Max. I am a software engineer with 3+ years of experience working on-site and remotely. I have worked on and launched several production-grade applications. I have a strong background in developing React.js, Node.js and Golang and I can easily adapt to various types of projects and architectures.
I am flexible to project demands and shifting of priorities. I thrive in unfamiliar situations and enjoy opportunities to learn and gain exposure to new ideas and experiences.</description>
    </item>
    
  </channel>
</rss>