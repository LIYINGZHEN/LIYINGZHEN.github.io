<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>stack on Max Li</title>
    <link>https://www.maxlivinci.com/tags/stack/</link>
    <description>Recent content in stack on Max Li</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 03 May 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.maxlivinci.com/tags/stack/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Stack - Find maximum of minimum for every window size</title>
      <link>https://www.maxlivinci.com/algorithm/stack_find_maximum_of_minimum_for_every_window_size/</link>
      <pubDate>Sun, 03 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_find_maximum_of_minimum_for_every_window_size/</guid>
      <description>Given an integer array of size n, find the maximum of the minimum’s of every window size in the array. Note that window size varies from 1 to n.
Example:
Input: arr[] = {10, 20, 30, 50, 10, 70, 30} Output: 70, 30, 20, 10, 10, 10, 10 First element in output indicates maximum of minimums of all windows of size 1. Minimums of windows of size 1 are {10}, {20}, {30}, {50}, {10}, {70} and {30}.</description>
    </item>
    
    <item>
      <title>Stack - Implement Stack using Queues</title>
      <link>https://www.maxlivinci.com/algorithm/stack_implement_stack_using_queues/</link>
      <pubDate>Sun, 03 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_implement_stack_using_queues/</guid>
      <description>We are given a Queue data structure that supports standard operations like enqueue() and dequeue(). We need to implement a Stack data structure using only instances of Queue and queue operations allowed on the instances.
 METHOD 1 (Reorganize while pushing)
import org.junit.Test; import java.util.LinkedList; import java.util.Queue; import static org.junit.Assert.assertEquals; public class StackUsingTwoQueues { class Stack { Queue&amp;lt;Integer&amp;gt; q1; Queue&amp;lt;Integer&amp;gt; q2; Stack() { q1 = new LinkedList&amp;lt;&amp;gt;(); q2 = new LinkedList&amp;lt;&amp;gt;(); } void push(int ele) { while (!</description>
    </item>
    
    <item>
      <title>Stack - K stacks in an array </title>
      <link>https://www.maxlivinci.com/algorithm/stack_k_stacks_in_an_array/</link>
      <pubDate>Sat, 02 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_k_stacks_in_an_array/</guid>
      <description>Create a data structure kStacks that represents k stacks. Implementation of kStacks should use only one array, i.e., k stacks should use the same array for storing elements. Following functions must be supported by kStacks.
 push(int x, int sn) –&amp;gt; pushes x to stack number ‘sn’ where sn is from 0 to k-1 pop(int sn) –&amp;gt; pops an element from stack number ‘sn’ where sn is from 0 to k-1   METHOD 1</description>
    </item>
    
    <item>
      <title>Stack - Largest rectangular area in a histogram</title>
      <link>https://www.maxlivinci.com/algorithm/stack_largest_rectangular_area_in_a_histogram/</link>
      <pubDate>Fri, 01 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_largest_rectangular_area_in_a_histogram/</guid>
      <description>Find the largest rectangular area possible in a given histogram where the largest rectangle can be made of a number of contiguous bars. For simplicity, assume that all bars have same width and the width is 1 unit.
For example, consider the following histogram with 7 bars of heights {6, 2, 5, 4, 5, 1, 6}. The largest possible rectangle possible is 12 (see the below figure, the max area rectangle is highlighted in red)</description>
    </item>
    
    <item>
      <title>Stack - Maximum of minimum for every window size</title>
      <link>https://www.maxlivinci.com/algorithm/stack_maximum_of_minimum_for_every_window_size/</link>
      <pubDate>Fri, 01 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_maximum_of_minimum_for_every_window_size/</guid>
      <description>Given an integer array of size n, find the maximum of the minimum’s of every window size in the array. Note that window size varies from 1 to n.
Example:
Input: arr[] = {10, 20, 30, 50, 10, 70, 30} Output: 70, 30, 20, 10, 10, 10, 10 First element in output indicates maximum of minimums of all windows of size 1. Minimums of windows of size 1 are {10}, {20}, {30}, {50}, {10}, {70} and {30}.</description>
    </item>
    
    <item>
      <title>Stack - Delete middle element of a stack</title>
      <link>https://www.maxlivinci.com/algorithm/stack_delete_middle_element/</link>
      <pubDate>Thu, 30 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_delete_middle_element/</guid>
      <description>Given a stack with push(), pop(), empty() operations, delete middle of it without using any additional data structure.
Example:
Input : Stack[] = [1, 2, 3, 4, 5] Output : Stack[] = [1, 2, 4, 5] Input : Stack[] = [1, 2, 3, 4, 5, 6] Output : Stack[] = [1, 2, 4, 5, 6]  METHOD 1 (Iterative)
import org.junit.Test; import java.util.Stack; import static org.junit.Assert.assertArrayEquals; /** * Author : Max * Question : https://www.</description>
    </item>
    
    <item>
      <title>Stack - Evaluation of Postfix Expression</title>
      <link>https://www.maxlivinci.com/algorithm/stack_evaluation_of_postfix_expression/</link>
      <pubDate>Thu, 30 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_evaluation_of_postfix_expression/</guid>
      <description>Evaluation of Postfix Expression.
METHOD 1
import org.junit.Test; import java.util.Stack; import static org.junit.Assert.assertEquals; /** * Author : Max * Question : https://www.geeksforgeeks.org/stack-set-4-evaluation-postfix-expression/ * Complexity : time: O(n) ; space: O(n) */ public class EvaluationOfPostfixExpression { static int evaluatePostfix(String exp) { char[] charArr = exp.toCharArray(); Stack&amp;lt;Integer&amp;gt; s = new Stack&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; charArr.length; i++) { char c = charArr[i]; if (Character.isDigit(c)) { s.push(c - &amp;#39;0&amp;#39;); } else { int val1 = s.</description>
    </item>
    
    <item>
      <title>Stack - Expression contains redundant bracket or not</title>
      <link>https://www.maxlivinci.com/algorithm/stack_expression_contains_redundant_bracket_or_not/</link>
      <pubDate>Thu, 30 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_expression_contains_redundant_bracket_or_not/</guid>
      <description>Given a string of balanced expression, find if it contains a redundant parenthesis or not. A set of parenthesis are redundant if same sub-expression is surrounded by unnecessary or multiple brackets.
Note: Expression may contain +, *, – and / operators. Given expression is valid and there are no white spaces present.
Example:
Input: ((a+b)) (a+(b)/c) (a+b*(c-d)) Output: Yes Yes No Explanation: 1. ((a+b)) can reduced to (a+b), this Redundant 2.</description>
    </item>
    
    <item>
      <title>Stack - Next greater element in an array</title>
      <link>https://www.maxlivinci.com/algorithm/stack_next_greater_element/</link>
      <pubDate>Wed, 29 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_next_greater_element/</guid>
      <description>Given an array, print the Next Greater Element (NGE) for every element. The Next greater Element for an element x is the first greater element on the right side of x in array. Elements for which no greater element exist, consider next greater element as -1.
 METHOD 1
import java.util.Stack; public class NextGreaterElement { // Time: O(n), Space: O(n)  static void printNGE(int[] arr) { if (arr == null || arr.</description>
    </item>
    
    <item>
      <title>Stack - Next greater element in an array</title>
      <link>https://www.maxlivinci.com/algorithm/stack_the_celebrity_problem/</link>
      <pubDate>Wed, 29 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_the_celebrity_problem/</guid>
      <description>In a party of N people, only one person is known to everyone. Such a person may be present in the party, if yes, (s)he doesn’t know anyone in the party. We can only ask questions like “does A know B? “. Find the stranger (celebrity) in the minimum number of questions.
We can describe the problem input as an array of numbers/characters representing persons in the party. We also have a hypothetical function HaveAcquaintance(A, B) which returns true if A knows B, false otherwise.</description>
    </item>
    
    <item>
      <title>Stack - Next greater element in an array</title>
      <link>https://www.maxlivinci.com/algorithm/stack_the_stock_span_problem/</link>
      <pubDate>Wed, 29 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_the_stock_span_problem/</guid>
      <description>The stock span problem is a financial problem where we have a series of n daily price quotes for a stock and we need to calculate span of stock’s price for all n days. The span Si of the stock’s price on a given day i is defined as the maximum number of consecutive days just before the given day, for which the price of the stock on the current day is less than or equal to its price on the given day.</description>
    </item>
    
    <item>
      <title>Stack - Implement two stacks in an array</title>
      <link>https://www.maxlivinci.com/algorithm/stack_implement_two_stacks_in_an_array/</link>
      <pubDate>Tue, 28 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_implement_two_stacks_in_an_array/</guid>
      <description>Create a data structure twoStacks that represents two stacks. Implementation of twoStacks should use only one array, i.e., both stacks should use the same array for storing elements. Following functions must be supported by twoStacks.
 push1(int x) –&amp;gt; pushes x to first stack push2(int x) –&amp;gt; pushes x to second stack pop1() –&amp;gt; pops an element from first stack and return the popped element pop2() –&amp;gt; pops an element from second stack and return the popped element   METHOD 1</description>
    </item>
    
    <item>
      <title>Stack - Check for balanced parentheses</title>
      <link>https://www.maxlivinci.com/algorithm/stack_check_for_balanced_parentheses/</link>
      <pubDate>Mon, 27 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_check_for_balanced_parentheses/</guid>
      <description>Given an expression string exp , write a program to examine whether the pairs and the orders of “{“,”}”,”(“,”)”,”[“,”]” are correct in exp.
Example:
Input: exp = “[()]{}{[()()]()}” Output: Balanced Input: exp = “[(])” Output: Not Balanced  METHOD 1
import java.util.Stack; public class BalancedParen { static boolean isPair(char a, char b) { if (a == &amp;#39;(&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;)&amp;#39; || a == &amp;#39;[&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;]&amp;#39; || a == &amp;#39;{&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;}&amp;#39;) { return true; } return false; } static boolean isBalance(char[] arr) { if (arr.</description>
    </item>
    
  </channel>
</rss>