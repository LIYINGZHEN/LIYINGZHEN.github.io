<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>stack on Max Li</title>
    <link>https://www.maxlivinci.com/tags/stack/</link>
    <description>Recent content in stack on Max Li</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Wed, 27 May 2020 05:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.maxlivinci.com/tags/stack/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Stack questions</title>
      <link>https://www.maxlivinci.com/algorithm/_6_stack/</link>
      <pubDate>Wed, 27 May 2020 05:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/_6_stack/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Stack - Iterative Tower of Hanoi</title>
      <link>https://www.maxlivinci.com/algorithm/stack_tower_of_hanoi/</link>
      <pubDate>Sun, 17 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_tower_of_hanoi/</guid>
      <description>Tower of Hanoi is a mathematical puzzle. It consists of three poles and a number of disks of different sizes which can slide onto any poles. The puzzle starts with the disk in a neat stack in ascending order of size in one pole, the smallest at the top thus making a conical shape. The objective of the puzzle is to move all the disks from one pole (say ‘source pole’) to another pole (say ‘destination pole’) with the help of the third pole (say auxiliary pole).</description>
    </item>
    
    <item>
      <title>Stack - Next greater element in an array</title>
      <link>https://www.maxlivinci.com/algorithm/stack_the_stock_span_problem/</link>
      <pubDate>Sat, 16 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_the_stock_span_problem/</guid>
      <description>The stock span problem is a financial problem where we have a series of n daily price quotes for a stock and we need to calculate span of stock’s price for all n days. The span Si of the stock’s price on a given day i is defined as the maximum number of consecutive days just before the given day, for which the price of the stock on the current day is less than or equal to its price on the given day.</description>
    </item>
    
    <item>
      <title>Stack - Next greater element in an array</title>
      <link>https://www.maxlivinci.com/algorithm/stack_the_celebrity_problem/</link>
      <pubDate>Fri, 15 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_the_celebrity_problem/</guid>
      <description>In a party of N people, only one person is known to everyone. Such a person may be present in the party, if yes, (s)he doesn’t know anyone in the party. We can only ask questions like “does A know B? “. Find the stranger (celebrity) in the minimum number of questions.
We can describe the problem input as an array of numbers/characters representing persons in the party. We also have a hypothetical function HaveAcquaintance(A, B) which returns true if A knows B, false otherwise.</description>
    </item>
    
    <item>
      <title>Stack - Next greater element in an array</title>
      <link>https://www.maxlivinci.com/algorithm/stack_next_greater_element/</link>
      <pubDate>Thu, 14 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_next_greater_element/</guid>
      <description>Given an array, print the Next Greater Element (NGE) for every element. The Next greater Element for an element x is the first greater element on the right side of x in array. Elements for which no greater element exist, consider next greater element as -1.
 METHOD 1
import java.util.Stack; public class NextGreaterElement { // Time: O(n), Space: O(n)  static void printNGE(int[] arr) { if (arr == null || arr.</description>
    </item>
    
    <item>
      <title>Stack - Maximum of minimum for every window size</title>
      <link>https://www.maxlivinci.com/algorithm/stack_maximum_of_minimum_for_every_window_size/</link>
      <pubDate>Wed, 13 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_maximum_of_minimum_for_every_window_size/</guid>
      <description>Given an integer array of size n, find the maximum of the minimum’s of every window size in the array. Note that window size varies from 1 to n.
Example:
Input: arr[] = {10, 20, 30, 50, 10, 70, 30} Output: 70, 30, 20, 10, 10, 10, 10 First element in output indicates maximum of minimums of all windows of size 1. Minimums of windows of size 1 are {10}, {20}, {30}, {50}, {10}, {70} and {30}.</description>
    </item>
    
    <item>
      <title>Stack - Largest rectangular area in a histogram</title>
      <link>https://www.maxlivinci.com/algorithm/stack_largest_rectangular_area_in_a_histogram/</link>
      <pubDate>Tue, 12 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_largest_rectangular_area_in_a_histogram/</guid>
      <description>Find the largest rectangular area possible in a given histogram where the largest rectangle can be made of a number of contiguous bars. For simplicity, assume that all bars have same width and the width is 1 unit.
For example, consider the following histogram with 7 bars of heights {6, 2, 5, 4, 5, 1, 6}. The largest possible rectangle possible is 12 (see the below figure, the max area rectangle is highlighted in red)</description>
    </item>
    
    <item>
      <title>Stack - K stacks in an array </title>
      <link>https://www.maxlivinci.com/algorithm/stack_k_stacks_in_an_array/</link>
      <pubDate>Mon, 11 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_k_stacks_in_an_array/</guid>
      <description>Create a data structure kStacks that represents k stacks. Implementation of kStacks should use only one array, i.e., k stacks should use the same array for storing elements. Following functions must be supported by kStacks.
 push(int x, int sn) –&amp;gt; pushes x to stack number ‘sn’ where sn is from 0 to k-1 pop(int sn) –&amp;gt; pops an element from stack number ‘sn’ where sn is from 0 to k-1   METHOD 1</description>
    </item>
    
    <item>
      <title>Stack - Implement two stacks in an array</title>
      <link>https://www.maxlivinci.com/algorithm/stack_implement_two_stacks_in_an_array/</link>
      <pubDate>Sun, 10 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_implement_two_stacks_in_an_array/</guid>
      <description>Create a data structure twoStacks that represents two stacks. Implementation of twoStacks should use only one array, i.e., both stacks should use the same array for storing elements. Following functions must be supported by twoStacks.
 push1(int x) –&amp;gt; pushes x to first stack push2(int x) –&amp;gt; pushes x to second stack pop1() –&amp;gt; pops an element from first stack and return the popped element pop2() –&amp;gt; pops an element from second stack and return the popped element   METHOD 1</description>
    </item>
    
    <item>
      <title>Stack - Implement Stack using Queues</title>
      <link>https://www.maxlivinci.com/algorithm/stack_implement_stack_using_queues/</link>
      <pubDate>Sat, 09 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_implement_stack_using_queues/</guid>
      <description>We are given a Queue data structure that supports standard operations like enqueue() and dequeue(). We need to implement a Stack data structure using only instances of Queue and queue operations allowed on the instances.
 METHOD 1 (Reorganize while pushing)
import org.junit.Test; import java.util.LinkedList; import java.util.Queue; import static org.junit.Assert.assertEquals; public class StackUsingTwoQueues { class Stack { Queue&amp;lt;Integer&amp;gt; q1; Queue&amp;lt;Integer&amp;gt; q2; Stack() { q1 = new LinkedList&amp;lt;&amp;gt;(); q2 = new LinkedList&amp;lt;&amp;gt;(); } void push(int ele) { while (!</description>
    </item>
    
  </channel>
</rss>