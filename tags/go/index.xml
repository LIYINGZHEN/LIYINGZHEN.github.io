<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on YING ZHEN LI</title>
    <link>https://www.maxlivinci.com/tags/go/</link>
    <description>Recent content in Go on YING ZHEN LI</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 30 Apr 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.maxlivinci.com/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Update map values in Go</title>
      <link>https://www.maxlivinci.com/blog/2019-04-30-update-map-values-in-go/</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-30-update-map-values-in-go/</guid>
      <description>We can&amp;rsquo;t change values associated with keys in a map, we can only reassign values.
So this leaves us 2 possible options:
 1. Store pointers in the map, so you can modify the pointed object (which is not inside the map data structure). 2. Store struct values, but when you modify it, you need to reassign it to the key.  1. Using pointers Storing pointers in the map: dataManaged := map[string]*Data{}</description>
    </item>
    
    <item>
      <title>Pass by pointer vs pass by value in Go</title>
      <link>https://www.maxlivinci.com/blog/2019-04-29-pass-by-pointer-vs-pass-by-value-in-go/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-29-pass-by-pointer-vs-pass-by-value-in-go/</guid>
      <description>Go allows to pass parameters both by pointers (sometimes it’s called by reference) and by values. In this post we will compare both approaches, paying special attention to different contexts that may affect the choice.
Pass by pointer vs pass by value Strictly speaking, there is only one way to pass parameters in Go - by value. Every time a variable is passed as parameter, a new copy of the variable is created and passed to called function or method.</description>
    </item>
    
    <item>
      <title>Go Tooling Essentials</title>
      <link>https://www.maxlivinci.com/blog/2019-04-28-go-tooling-essentials/</link>
      <pubDate>Sun, 28 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-28-go-tooling-essentials/</guid>
      <description>New to the Go tools? Or do you want to expand your knowledge? This article is about the flags for the Go tools everyone should know.
$ go test -v It provides chatty output for the testing. It prints the test name, its status (failed or passed), how much it took to run the test, any logs from the test case, etc.
go test without the -v flag is highly quiet, I always use it with -v turned on.</description>
    </item>
    
    <item>
      <title>Unit Testing HTTP Servers</title>
      <link>https://www.maxlivinci.com/blog/2019-04-27-unit-testing-http-servers/</link>
      <pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-27-unit-testing-http-servers/</guid>
      <description>You’re building a web (HTTP) service in Go, and you want to unit test your handler functions. You’ve got a grip on Go’s net/http package, but you’re not sure where to start with testing that your handlers return the correct HTTP status codes, HTTP headers or response bodies.
Let’s walk through how you go about this, injecting the necessary dependencies, and mocking the rest.
A Basic Handler We’ll start by writing a basic test: we want to make sure our handler returns a HTTP 200 (OK) status code.</description>
    </item>
    
    <item>
      <title>JSON and Go</title>
      <link>https://www.maxlivinci.com/blog/2019-04-26-json-and-go/</link>
      <pubDate>Fri, 26 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-26-json-and-go/</guid>
      <description>Parsing a format like JSON in a statically typed language like Go presents a bit of a problem. If anything could show up in the JSON body, how does the compiler know how to setup memory to have a spot to place everything?
There are two answers to this. The easy option, for when you know what your data will look like, is to parse the JSON into a struct you’ve defined.</description>
    </item>
    
    <item>
      <title>Efficient String Concatenation in Go</title>
      <link>https://www.maxlivinci.com/blog/2019-04-25-efficient-string-concatenation-in-go/</link>
      <pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-25-efficient-string-concatenation-in-go/</guid>
      <description>In this article I investigate the computational performance of various string concatenation methods in the Go programming language.
To evaluate the options, I prepared some typical Go benchmarks using the Go testing package. A benchmark looks something like this:
func BenchmarkNative(b *testing.B) { var s string next := nextString() for i := 0; i &amp;lt; b.N; i++ { s += next() } }  For the purposes of these benchmarks, I imagined having a process that returns string segments one by one, and these segments need to be concatenated to form one string.</description>
    </item>
    
    <item>
      <title>Writing middleware in Golang</title>
      <link>https://www.maxlivinci.com/blog/2019-04-24-writing-middleware-in-golang/</link>
      <pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-24-writing-middleware-in-golang/</guid>
      <description>When we talk about Middleware in Go, at its simplest, we are really talking about running code before and/or after our handler code in a HTTP request lifecycle. For example, logging middleware might write the incoming request details to a log, then call the handler code, before writing details about the response to the log. One of the cool things about middleware, if implemented correctly, is that these units are extremely flexible, reusable, and sharable.</description>
    </item>
    
    <item>
      <title>Working with Files in Go</title>
      <link>https://www.maxlivinci.com/blog/2019-04-23-working-with-files-in-go/</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-23-working-with-files-in-go/</guid>
      <description>One of the fundamental aspects of UNIX is that everything is a file. We don&amp;rsquo;t necessarily know what the file descriptor maps to, that is abstracted by the operating system&amp;rsquo;s device drivers. The operating system provides us an interface to the device in the form of a file.
The reader and writer interfaces in Go are similar abstractions. We simply read and write bytes, without the need to understand where or how the reader gets its data or where the writer is sending the data.</description>
    </item>
    
    <item>
      <title>Slices from the ground up</title>
      <link>https://www.maxlivinci.com/blog/2019-04-22-slices-from-the-ground-up/</link>
      <pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-22-slices-from-the-ground-up/</guid>
      <description>Arrays Arrays in Go have two relevant properties:
 They have a fixed size; [5]int is is distinct from [3]int. They are value types. Consider this example:  package main import &amp;quot;fmt&amp;quot; func main() { var a [5]int b := a b[2] = 7 fmt.Println(a, b) // prints [0 0 0 0 0] [0 0 7 0 0] }  The statement b := a declares a new variable, b, of type [5]int, and copies the contents of a to b.</description>
    </item>
    
    <item>
      <title>Gopher Reading List</title>
      <link>https://www.maxlivinci.com/blog/2019-04-21-gopher-reading-list/</link>
      <pubDate>Sun, 21 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-04-21-gopher-reading-list/</guid>
      <description>Here is a reading list of blog posts about Go. It aspires to include only the most useful and relevant material that anyone writing Go should eventually read. By definition, the list is a work in progress.
Rather than being comprehensive, the list is a curated selection fixed at 200 entries.
Go is growing fast and so are the number of blog posts about it. If an interested reader knows of a great post not on this list, please open an issue with a link to the post.</description>
    </item>
    
  </channel>
</rss>