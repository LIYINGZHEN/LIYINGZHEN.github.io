<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithm on Max Li</title>
    <link>https://www.maxlivinci.com/tags/algorithm/</link>
    <description>Recent content in algorithm on Max Li</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 03 May 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.maxlivinci.com/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Stack - Find maximum of minimum for every window size</title>
      <link>https://www.maxlivinci.com/algorithm/stack_find_maximum_of_minimum_for_every_window_size/</link>
      <pubDate>Sun, 03 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_find_maximum_of_minimum_for_every_window_size/</guid>
      <description>Given an integer array of size n, find the maximum of the minimum’s of every window size in the array. Note that window size varies from 1 to n.
Example:
Input: arr[] = {10, 20, 30, 50, 10, 70, 30} Output: 70, 30, 20, 10, 10, 10, 10 First element in output indicates maximum of minimums of all windows of size 1. Minimums of windows of size 1 are {10}, {20}, {30}, {50}, {10}, {70} and {30}.</description>
    </item>
    
    <item>
      <title>Stack - K stacks in an array </title>
      <link>https://www.maxlivinci.com/algorithm/stack_k_stacks_in_an_array/</link>
      <pubDate>Sat, 02 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_k_stacks_in_an_array/</guid>
      <description>Create a data structure kStacks that represents k stacks. Implementation of kStacks should use only one array, i.e., k stacks should use the same array for storing elements. Following functions must be supported by kStacks.
 push(int x, int sn) –&amp;gt; pushes x to stack number ‘sn’ where sn is from 0 to k-1 pop(int sn) –&amp;gt; pops an element from stack number ‘sn’ where sn is from 0 to k-1   METHOD 1</description>
    </item>
    
    <item>
      <title>Stack - Largest rectangular area in a histogram</title>
      <link>https://www.maxlivinci.com/algorithm/stack_largest_rectangular_area_in_a_histogram/</link>
      <pubDate>Fri, 01 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_largest_rectangular_area_in_a_histogram/</guid>
      <description>Find the largest rectangular area possible in a given histogram where the largest rectangle can be made of a number of contiguous bars. For simplicity, assume that all bars have same width and the width is 1 unit.
For example, consider the following histogram with 7 bars of heights {6, 2, 5, 4, 5, 1, 6}. The largest possible rectangle possible is 12 (see the below figure, the max area rectangle is highlighted in red)</description>
    </item>
    
    <item>
      <title>Stack - Expression contains redundant bracket or not</title>
      <link>https://www.maxlivinci.com/algorithm/stack_expression_contains_redundant_bracket_or_not/</link>
      <pubDate>Thu, 30 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_expression_contains_redundant_bracket_or_not/</guid>
      <description>Given a string of balanced expression, find if it contains a redundant parenthesis or not. A set of parenthesis are redundant if same sub-expression is surrounded by unnecessary or multiple brackets.
Note: Expression may contain +, *, – and / operators. Given expression is valid and there are no white spaces present.
Example:
Input: ((a+b)) (a+(b)/c) (a+b*(c-d)) Output: Yes Yes No Explanation: 1. ((a+b)) can reduced to (a+b), this Redundant 2.</description>
    </item>
    
    <item>
      <title>Stack - Next greater element in an array</title>
      <link>https://www.maxlivinci.com/algorithm/stack_next_greater_element/</link>
      <pubDate>Wed, 29 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_next_greater_element/</guid>
      <description>Given an array, print the Next Greater Element (NGE) for every element. The Next greater Element for an element x is the first greater element on the right side of x in array. Elements for which no greater element exist, consider next greater element as -1.
 METHOD 1
import java.util.Stack; public class NextGreaterElement { // Time: O(n), Space: O(n)  static void printNGE(int[] arr) { if (arr == null || arr.</description>
    </item>
    
    <item>
      <title>Stack - Implement two stacks in an array</title>
      <link>https://www.maxlivinci.com/algorithm/stack_implement_two_stacks_in_an_array/</link>
      <pubDate>Tue, 28 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_implement_two_stacks_in_an_array/</guid>
      <description>Create a data structure twoStacks that represents two stacks. Implementation of twoStacks should use only one array, i.e., both stacks should use the same array for storing elements. Following functions must be supported by twoStacks.
 push1(int x) –&amp;gt; pushes x to first stack push2(int x) –&amp;gt; pushes x to second stack pop1() –&amp;gt; pops an element from first stack and return the popped element pop2() –&amp;gt; pops an element from second stack and return the popped element   METHOD 1</description>
    </item>
    
    <item>
      <title>Stack - Check for balanced parentheses</title>
      <link>https://www.maxlivinci.com/algorithm/stack_check_for_balanced_parentheses/</link>
      <pubDate>Mon, 27 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/stack_check_for_balanced_parentheses/</guid>
      <description>Given an expression string exp , write a program to examine whether the pairs and the orders of “{“,”}”,”(“,”)”,”[“,”]” are correct in exp.
Example:
Input: exp = “[()]{}{[()()]()}” Output: Balanced Input: exp = “[(])” Output: Not Balanced  METHOD 1
import java.util.Stack; public class BalancedParen { static boolean isPair(char a, char b) { if (a == &amp;#39;(&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;)&amp;#39; || a == &amp;#39;[&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;]&amp;#39; || a == &amp;#39;{&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;}&amp;#39;) { return true; } return false; } static boolean isBalance(char[] arr) { if (arr.</description>
    </item>
    
    <item>
      <title>Linked List - Find length of Loop</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_find_length_of_loop/</link>
      <pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_find_length_of_loop/</guid>
      <description>Write a function detectAndCountLoop() that checks whether a given Linked List contains loop and if loop is present then returns count of nodes in loop. For example, loop is present in below linked list and length of loop is 4. If loop is not present, then function should return 0.
 METHOD 1
import org.junit.Test; import static org.junit.Assert.assertEquals; public class FindLengthOfLoop { static int countNodesinLoop(Node head) { if (head == null) { return 0; } Node slow = head, fast = head; boolean hasLoop = false; while (fast !</description>
    </item>
    
    <item>
      <title>Linked List - Find start of the loop</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_find_start_of_the_loop/</link>
      <pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_find_start_of_the_loop/</guid>
      <description>Write a function findFirstLoopNode() that checks whether a given Linked List contains loop. If loop is present then it returns point to first node of loop. Else it returns NULL.
Example :
Input : Head of bellow linked list Output : Pointer to node 2  METHOD 1
public class FindStartNodeInLoop{ private Node head; private static class Node { private int data; private Node next; Node(int d) { this.data = d; } } public void addToTheLast(Node node) { if (head == null) { head = node; } else { Node temp = head; while (temp.</description>
    </item>
    
    <item>
      <title>Linked List - Find the middle of a given linked list</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_find_the_middle_node/</link>
      <pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_find_the_middle_node/</guid>
      <description>Given a singly linked list, find middle of the linked list. For example, if given linked list is 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 then output should be 3.
 If there are even nodes, then there would be two middle nodes, we want to print first middle element. For example, if given linked list is 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6 then output should be 4.
METHOD 1
 This is much useful in merge sort.
 import org.junit.Test; import static org.</description>
    </item>
    
    <item>
      <title>Linked List - Remove loop in Linked List</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_remove_loop_in_linked_list/</link>
      <pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_remove_loop_in_linked_list/</guid>
      <description>Write a function detectAndRemoveLoop() that checks whether a given Linked List contains loop and if loop is present then removes the loop and returns true. If the list doesn’t contain loop then it returns false. Below diagram shows a linked list with a loop. detectAndRemoveLoop() must change the below list to 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL.
 METHOD 1
import org.junit.Test; import static org.junit.Assert.assertArrayEquals; public class RemoveLoop { static boolean detectAndRemoveLoop(Node head) { if (head == null) { return false; } Node slow = head, fast = head; boolean hasLoop = false; while (fast !</description>
    </item>
    
    <item>
      <title>Linked List - Add two numbers</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_add_two_numbers/</link>
      <pubDate>Sat, 25 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_add_two_numbers/</guid>
      <description>Given two numbers represented by two lists, write a function that returns the sum list. The sum list is list representation of the addition of two input numbers.
Examples :
Input: List1: 5-&amp;gt;6-&amp;gt;3 // number 365 List2: 8-&amp;gt;4-&amp;gt;2 // number 248 Output: Resultant list: 3-&amp;gt;1-&amp;gt;6 // number 613 Input: List1: 7-&amp;gt;5-&amp;gt;9-&amp;gt;4-&amp;gt;6 // number 64957 List2: 8-&amp;gt;4 // number 48 Output: Resultant list: 5-&amp;gt;0-&amp;gt;0-&amp;gt;5-&amp;gt;6 // number 65005  METHOD 1 (Recursively)</description>
    </item>
    
    <item>
      <title>Linked List - Nth node from end of linked list</title>
      <link>https://www.maxlivinci.com/algorithm/linked_nth_node_from_end_of_linked_list/</link>
      <pubDate>Fri, 24 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_nth_node_from_end_of_linked_list/</guid>
      <description>Given a Linked List and a number n, write a function that returns the value at the n’th node from the end of the Linked List.
For example, if the input is below list and n = 3, then output is “B”
 METHOD 1
import org.junit.Test; import static org.junit.Assert.assertEquals; public class NthNodeFromEnd { // Time: O(n) ; Space: O(1)  static int nthFromLast(Node head, int n) { if (n &amp;lt; 1) { return Integer.</description>
    </item>
    
    <item>
      <title>Linked List - Reverse every alternate k nodes</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_reverse_every_alternate_k_nodes/</link>
      <pubDate>Fri, 24 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_reverse_every_alternate_k_nodes/</guid>
      <description>Given a linked list, write a function to reverse every alternate k nodes (where k is an input to the function) in an efficient way. Give the complexity of your algorithm.
Examples :
Inputs: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6-&amp;gt;7-&amp;gt;8-&amp;gt;9-&amp;gt;NULL and k = 3 Output: 3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5-&amp;gt;6-&amp;gt;9-&amp;gt;8-&amp;gt;7-&amp;gt;NULL.  METHOD 1
public class ReverseInAlternateKPair { Node head; class Node { int data; Node next; Node(int d) {data = d; next = null; } } public void push(int new_data) { Node new_node = new Node(new_data); new_node.</description>
    </item>
    
    <item>
      <title>Linked List - Rotate a Linked List</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_rotate_a_linked_list/</link>
      <pubDate>Fri, 24 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_rotate_a_linked_list/</guid>
      <description>Given a singly linked list, rotate the linked list counter-clockwise by k nodes. Where k is a given positive integer. For example, if the given linked list is 10-&amp;gt;20-&amp;gt;30-&amp;gt;40-&amp;gt;50-&amp;gt;60 and k is 4, the list should be modified to 50-&amp;gt;60-&amp;gt;10-&amp;gt;20-&amp;gt;30-&amp;gt;40. Assume that k is smaller than the count of nodes in linked list.
 METHOD 1
import org.junit.Test; import static org.junit.Assert.assertArrayEquals; public class RotateALinkedList { // Time: O(n) ; Space: O(1)  static Node rotate(Node head, int k) { if (head == null) { return null; } int n = 0; Node temp = head; while (temp !</description>
    </item>
    
    <item>
      <title>Linked List - Merge two sorted linked lists</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_merge_two_sorted_linked_lists/</link>
      <pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_merge_two_sorted_linked_lists/</guid>
      <description>Write a sortedMerge() function that takes two lists, each of which is sorted in increasing order, and merges the two together into one list which is in increasing order.
 METHOD 1 (Iteratively)
import org.junit.Test; import static org.junit.Assert.assertArrayEquals; public class MergeTwoSortedLinkedLists { // Time: O(n) ; Space: O(1)  static Node sortedMerge(Node headA, Node headB) { Node d = new Node(0); Node tail = d; Node currA = headA; Node currB = headB; while (currA !</description>
    </item>
    
    <item>
      <title>Linked List - Pairwise swap of nodes in LinkeList</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_pairwise_swap_of_nodes/</link>
      <pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_pairwise_swap_of_nodes/</guid>
      <description>Given a singly linked list, write a function to swap elements pairwise.
Input : 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6-&amp;gt;NULL Output : 2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;6-&amp;gt;5-&amp;gt;NULL Input : 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL Output : 2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5-&amp;gt;NULL Input : 1-&amp;gt;NULL Output : 1-&amp;gt;NULL  METHOD 1 (Recursively)
import org.junit.Test; import static org.junit.Assert.assertArrayEquals; public class PairwiseSwap { // Time: O(n) ; Space: O(n)  static Node pairWiseSwap(Node head) { if (head == null || head.next == null) { return head; } Node newHead = head.</description>
    </item>
    
    <item>
      <title>Linked List - Remove duplicates from a sorted linked list</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_remove_duplicates_from_a_sorted_linked_list.md/</link>
      <pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_remove_duplicates_from_a_sorted_linked_list.md/</guid>
      <description>Write a function which takes a list sorted in non-decreasing order and deletes any duplicate nodes from the list. The list should only be traversed once.
For example if the linked list is 11-&amp;gt;11-&amp;gt;11-&amp;gt;21-&amp;gt;43-&amp;gt;43-&amp;gt;60 then removeDuplicates() should convert the list to 11-&amp;gt;21-&amp;gt;43-&amp;gt;60.
 METHOD 1 (Iteratively)
import org.junit.Test; import static org.junit.Assert.assertArrayEquals; public class RemoveDuplicateElement { // Time: O(n) ; Space: O(1)  static void removeDuplicate(Node head) { if (head == null) { return; } Node curr = head; while (curr !</description>
    </item>
    
    <item>
      <title>Linked List - Remove duplicates from an unsorted linked list</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_remove_duplicates_from_an_unsorted_linked_list/</link>
      <pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_remove_duplicates_from_an_unsorted_linked_list/</guid>
      <description>Write a removeDuplicates() function which takes a list and deletes any duplicate nodes from the list. The list is not sorted.
For example if the linked list is 12-&amp;gt;11-&amp;gt;12-&amp;gt;21-&amp;gt;41-&amp;gt;43-&amp;gt;21 then removeDuplicates() should convert the list to 12-&amp;gt;11-&amp;gt;21-&amp;gt;41-&amp;gt;43.
 METHOD 1
import org.junit.Test; import java.util.HashSet; import static org.junit.Assert.assertArrayEquals; public class RemoveDuplicatesUnsorted { // Time: O(n) ; Space: O(n)  static void remove(Node head) { if (head == null) { return; } HashSet&amp;lt;Integer&amp;gt; h = new HashSet&amp;lt;&amp;gt;(); Node curr = head; Node prev = null; while (curr !</description>
    </item>
    
    <item>
      <title>Linked List - Reverse a linked list</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_reverse_a_linked_list/</link>
      <pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_reverse_a_linked_list/</guid>
      <description>Given pointer to the head node of a linked list, the task is to reverse the linked list. We need to reverse the list by changing links between nodes.
Examples :
Input: Head of following linked list 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;NULL Output: Linked list should be changed to, 4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL Input: Head of following linked list 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL Output: Linked list should be changed to, 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL Input: NULL Output: NULL Input: 1-&amp;gt;NULL Output: 1-&amp;gt;NULL  METHOD 1 (Recursively)</description>
    </item>
    
    <item>
      <title>Linked List - Merge sort</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_merge_sort/</link>
      <pubDate>Wed, 22 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_merge_sort/</guid>
      <description>Implement merge sort.
 METHOD 1
import org.junit.Test; import static org.junit.Assert.assertArrayEquals; public class MergeSort { static Node findMiddle(Node head) { if (head == null) { return null; } Node slow = head, fast = head.next; while (fast != null &amp;amp;&amp;amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } return slow; } static Node merge(Node headA, Node headB) { if (headA == null &amp;amp;&amp;amp; headB == null) { return null; } if (headA == null) { return headB; } if (headB == null) { return headA; } if (headA.</description>
    </item>
    
    <item>
      <title>Array - Count inversions</title>
      <link>https://www.maxlivinci.com/algorithm/array_count_inversions_in_an_array/</link>
      <pubDate>Tue, 21 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/array_count_inversions_in_an_array/</guid>
      <description>Inversion Count for an array indicates – how far (or close) the array is from being sorted. If array is already sorted then inversion count is 0. If array is sorted in reverse order that inversion count is the maximum.
Formally speaking, two elements a[i] and a[j] form an inversion if a[i] &amp;gt; a[j] and i &amp;lt; j
Example:
Input: arr[] = {8, 4, 2, 1} Output: 6 Explanation: Given array has six inversions: (8,4), (4,2),(8,2), (8,1), (4,1), (2,1).</description>
    </item>
    
    <item>
      <title>Linked List - Insertion</title>
      <link>https://www.maxlivinci.com/algorithm/linked_list_insertion/</link>
      <pubDate>Tue, 21 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/linked_list_insertion/</guid>
      <description>Given a singly linked list, a position and an element, the task is to write a program to insert that element in a linked list at a given position.
Examples :
Input: 3-&amp;gt;5-&amp;gt;8-&amp;gt;10, data = 2, position = 2 Output: 3-&amp;gt;2-&amp;gt;5-&amp;gt;8-&amp;gt;10 Input: 3-&amp;gt;5-&amp;gt;8-&amp;gt;10, data = 11, position = 5 Output: 3-&amp;gt;5-&amp;gt;8-&amp;gt;10-&amp;gt;11  METHOD 1
public class Insertion { // Time : O(n) ; Space: O(1)  static void insert(LinkedList ll, int data, int pos) { int step = pos - 1; if (step &amp;lt; 0 || step &amp;gt; ll.</description>
    </item>
    
    <item>
      <title>Array - Find pair in a sorted rotated array</title>
      <link>https://www.maxlivinci.com/algorithm/array_find_pair_in_a_sorted_rotated_array/</link>
      <pubDate>Mon, 20 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/array_find_pair_in_a_sorted_rotated_array/</guid>
      <description>Given an array that is sorted and then rotated around an unknown point. Find if the array has a pair with a given sum ‘x’. It may be assumed that all elements in the array are distinct.
Examples :
Input: arr[] = {11, 15, 6, 8, 9, 10}, x = 16 Output: true There is a pair (6, 10) with sum 16 Input: arr[] = {11, 15, 26, 38, 9, 10}, x = 35 Output: true There is a pair (26, 9) with sum 35 Input: arr[] = {11, 15, 26, 38, 9, 10}, x = 45 Output: false There is no pair with sum 45.</description>
    </item>
    
    <item>
      <title>Array - Rotate an array</title>
      <link>https://www.maxlivinci.com/algorithm/array_rotate_an_array/</link>
      <pubDate>Sun, 19 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/array_rotate_an_array/</guid>
      <description>Write a function rotate(ar[], d, n) that rotates arr[] of size n by d elements.
Rotation of the above array by 2 will make array
 METHOD 1
import org.junit.Test; import static org.junit.Assert.assertArrayEquals; public class RotateArray { // Time: O(n), Space: O(1)  static void rotateArr(int arr[], int d) { if (arr.length == 0) { return; } int n = arr.length; int step = d % arr.length; int count = 0; for (int start = 0; count &amp;lt; n; start++) { int curr = start; int prev = arr[curr]; do { int next = (curr + n - step) % n; int temp = arr[next]; arr[next] = prev; prev = temp; curr = next; count++; } while (start !</description>
    </item>
    
    <item>
      <title>Array - Trapping rain water</title>
      <link>https://www.maxlivinci.com/algorithm/array_trapping_rain_water/</link>
      <pubDate>Sat, 18 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/array_trapping_rain_water/</guid>
      <description>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
Examples:
Input: arr[] = {2, 0, 2} Output: 2 Explanation: The structure is like below We can trap 2 units of water in the middle gap.  METHOD 1
import org.junit.Test; import static org.junit.Assert.assertEquals; public class TrappingRainWater { static int maxWater(int[] arr) { if (arr.</description>
    </item>
    
    <item>
      <title>Array - Maximum index</title>
      <link>https://www.maxlivinci.com/algorithm/array_maximum_index/</link>
      <pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/array_maximum_index/</guid>
      <description>Given an array arr[], find the maximum j – i such that arr[j] &amp;gt; arr[i]
 METHOD 1
import org.junit.Test; import static org.junit.Assert.assertEquals; public class MaximumIndex { // Time: O(n) ; Space: O(n)  static int maximun(int[] arr) { if (arr.length == 0) { return -1; } int n = arr.length; int[] maxFromTheRight = new int[n]; int max = Integer.MIN_VALUE; for (int i = n - 1; i &amp;gt;= 0; i--) { int num = arr[i]; if (num &amp;gt; max) { max = num; } maxFromTheRight[i] = max; } int i = 0, j = 0, maxDiff = -1; while (i &amp;lt; n &amp;amp;&amp;amp; j &amp;lt; n) { int num = arr[i]; if (num &amp;lt; maxFromTheRight[j]) { maxDiff = Math.</description>
    </item>
    
    <item>
      <title>Array - Rearrange an array so that arr[i] becomes arr[arr[i]]</title>
      <link>https://www.maxlivinci.com/algorithm/array_rearrange_an_array_so_that_arri_becomes_arrarri/</link>
      <pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/array_rearrange_an_array_so_that_arri_becomes_arrarri/</guid>
      <description>Given an array arr[] of size n where every element is in range from 0 to n-1. Rearrange the given array so that arr[i] becomes arr[arr[i]]. This should be done with O(1) extra space.
Example:
Input: arr[] = {3, 2, 0, 1} Output: arr[] = {1, 0, 3, 2}  METHOD 1
package array.max; import java.util.Arrays; public class Rearrange { static void rearrange(int[] arr) { // The value we get module with n will be the original number.</description>
    </item>
    
    <item>
      <title>Array - Rearrange an array such that arr[i] = i</title>
      <link>https://www.maxlivinci.com/algorithm/array_rearrange_an_array_such_that_arri__i/</link>
      <pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/array_rearrange_an_array_such_that_arri__i/</guid>
      <description>Given an array of elements of length N, ranging from 0 to N – 1. All elements may not be present in the array. If element is not present then there will be -1 present in the array. Rearrange the array such that A[i] = i and if i is not present, display -1 at that place.
Examples:
Input : arr = {-1, -1, 6, 1, 9, 3, 2, -1, 4, -1} Output : [-1, 1, 2, 3, 4, -1, 6, -1, -1, 9] Input : arr = {19, 7, 0, 3, 18, 15, 12, 6, 1, 8, 11, 10, 9, 5, 13, 16, 2, 14, 17, 4} Output : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]  METHOD 1</description>
    </item>
    
    <item>
      <title>Sorting - Merge sort</title>
      <link>https://www.maxlivinci.com/algorithm/sorting_merge_sort/</link>
      <pubDate>Thu, 16 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/sorting_merge_sort/</guid>
      <description>Implement merge sort.
 METHOD 1
import java.util.Arrays; public class MergeSort { public static void merge(int[] arr, int l, int h) { if (l &amp;gt;= h) { return; } int m = l + (h - l) / 2; int[] leftCopy = new int[m - l + 1]; int[] rightCopy = new int[h - m]; for (int i = 0; i &amp;lt; leftCopy.length; i++) { leftCopy[i] = arr[l + i]; } for (int i = 0; i &amp;lt; rightCopy.</description>
    </item>
    
    <item>
      <title>Sorting - Quick sort</title>
      <link>https://www.maxlivinci.com/algorithm/sorting_quick_sort/</link>
      <pubDate>Wed, 15 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/sorting_quick_sort/</guid>
      <description>Implement Quicksort.
 METHOD 1
import org.junit.Test; import static org.junit.Assert.assertArrayEquals; public class QuickSort { static void swap(int[] arr, int a, int b) { int temp = arr[b]; arr[b] = arr[a]; arr[a] = temp; } static int partiton(int[] arr, int l, int h) { int pivot = arr[h]; int i = l, p = l; while (i &amp;lt; h) { if (arr[i] &amp;lt; pivot) { swap(arr, i, p); p++; } i++; } swap(arr, i, p); return p; } // Time: O(nlogn) ; Space: O(1)  // In-place  static void quickSort(int[] arr, int l, int h) { if (l &amp;gt;= h) { return; } int p = partiton(arr, l, h); quickSort(arr, l, p - 1); quickSort(arr, p + 1, h); } @Test public void test() { int[] arr = {5, 4, 3, 2, 1}; quickSort(arr, 0, arr.</description>
    </item>
    
    <item>
      <title>Sorting - Sort an array of 0s, 1s and 2s</title>
      <link>https://www.maxlivinci.com/algorithm/sorting_sort_an_array_of_012/</link>
      <pubDate>Tue, 14 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/sorting_sort_an_array_of_012/</guid>
      <description>Given an array A[] consisting 0s, 1s and 2s. The task is to write a function that sorts the given array. The functions should put all 0s first, then all 1s and all 2s in last.
Examples:
Input: {0, 1, 2, 0, 1, 2} Output: {0, 0, 1, 1, 2, 2} Input: {0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1} Output: {0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2}  METHOD 1</description>
    </item>
    
    <item>
      <title>Sorting - Count inversions</title>
      <link>https://www.maxlivinci.com/algorithm/sorting_count_inversions/</link>
      <pubDate>Mon, 13 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/sorting_count_inversions/</guid>
      <description>Inversion Count for an array indicates – how far (or close) the array is from being sorted. If array is already sorted then inversion count is 0. If array is sorted in reverse order that inversion count is the maximum.
Formally speaking, two elements a[i] and a[j] form an inversion if a[i] &amp;gt; a[j] and i &amp;lt; j
Example:
Input: arr[] = {8, 4, 2, 1} Output: 6 Explanation: Given array has six inversions: (8,4), (4,2),(8,2), (8,1), (4,1), (2,1).</description>
    </item>
    
    <item>
      <title>Recursion - Josephus problem</title>
      <link>https://www.maxlivinci.com/algorithm/recursion_josephus_problem/</link>
      <pubDate>Sun, 12 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/recursion_josephus_problem/</guid>
      <description>There are n people standing in a circle waiting to be executed. The counting out begins at some point in the circle and proceeds around the circle in a fixed direction. In each step, a certain number of people are skipped and the next person is executed. The elimination proceeds around the circle (which is becoming smaller and smaller as the executed people are removed), until only the last person remains, who is given freedom.</description>
    </item>
    
    <item>
      <title>Recursion - Tower of hanoi</title>
      <link>https://www.maxlivinci.com/algorithm/recursion_tower_of_hanoi/</link>
      <pubDate>Sat, 11 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/algorithm/recursion_tower_of_hanoi/</guid>
      <description>The Tower of Hanoi is a mathematical game or puzzle. It consists of three rods and a number of disks of different sizes, which can slide onto any rod. The puzzle starts with the disks in a neat stack in ascending order of size on one rod, the smallest at the top, thus making a conical shape.
The objective of the puzzle is to move the entire stack to another rod, obeying the following simple rules:</description>
    </item>
    
  </channel>
</rss>