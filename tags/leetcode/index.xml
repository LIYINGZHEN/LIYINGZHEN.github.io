<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on MAX LI</title>
    <link>https://www.maxlivinci.com/tags/leetcode/</link>
    <description>Recent content in Leetcode on MAX LI</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 10 Jul 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.maxlivinci.com/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LeetCode - 674. Longest Continuous Increasing Subsequence</title>
      <link>https://www.maxlivinci.com/leetcode/2019-07-10-leetcode-674-longest-continuous-increasing-subsequence/</link>
      <pubDate>Wed, 10 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-07-10-leetcode-674-longest-continuous-increasing-subsequence/</guid>
      <description>LeetCode
Problem Statement Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).
Example 1:
Input: [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. Even though [1,3,5,7] is also an increasing subsequence, it&#39;s not a continuous one where 5 and 7 are separated by 4.  Example 2:
Input: [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2], its length is 1.</description>
    </item>
    
    <item>
      <title>LeetCode - 643. Maximum Average Subarray I</title>
      <link>https://www.maxlivinci.com/leetcode/2019-07-09-leetcode-643-maximum-average-subarray-i/</link>
      <pubDate>Tue, 09 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-07-09-leetcode-643-maximum-average-subarray-i/</guid>
      <description> LeetCode
Problem Statement Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value.
Example 1:
Input: [1,12,-5,-6,50,3], k = 4 Output: 12.75 Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75  Solution func findMaxAverage(nums []int, k int) float64 { sum := 0 for _, v := range nums[:k] { sum += v } maxSum, windowSum := sum, sum for i := 0; i &amp;lt; len(nums)-k; i++ { windowSum += nums[k+i] - nums[i] if windowSum &amp;gt; maxSum { maxSum = windowSum } } return float64(maxSum) / float64(k) }  </description>
    </item>
    
    <item>
      <title>LeetCode - 628. Maximum Product of Three Numbers</title>
      <link>https://www.maxlivinci.com/leetcode/2019-07-08-leetcode-628-maximum-product-of-three-numbers/</link>
      <pubDate>Mon, 08 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-07-08-leetcode-628-maximum-product-of-three-numbers/</guid>
      <description> LeetCode
Problem Statement Given an integer array, find three numbers whose product is maximum and output the maximum product.
Example 1:
Input: [1,2,3] Output: 6  Example 2:
Input: [1,2,3,4] Output: 24  Solution import &amp;quot;math&amp;quot; func maximumProduct(nums []int) int { min1, min2 := math.MaxInt32, math.MaxInt32 max1, max2, max3 := -math.MaxInt32, -math.MaxInt32, -math.MaxInt32 for _, v := range nums { if v &amp;gt; max1 { max3 = max2 max2 = max1 max1 = v } else if v &amp;gt; max2 { max3 = max2 max2 = v } else if v &amp;gt; max3 { max3 = v } if v &amp;lt; min1 { min2 = min1 min1 = v } else if v &amp;lt; min2 { min2 = v } } if max1*max2*max3 &amp;gt; max1*min1*min2 { return max1 * max2 * max3 } return max1 * min1 * min2 }  </description>
    </item>
    
    <item>
      <title>LeetCode - 581. Shortest Unsorted Continuous Subarray</title>
      <link>https://www.maxlivinci.com/leetcode/2019-07-06-leetcode-581-shortest-unsorted-continuous-subarray/</link>
      <pubDate>Sat, 06 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-07-06-leetcode-581-shortest-unsorted-continuous-subarray/</guid>
      <description>LeetCode
Problem Statement Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.
You need to find the shortest such subarray and output its length.
Example:
Input: [2, 6, 4, 8, 10, 9, 15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.</description>
    </item>
    
    <item>
      <title>LeetCode - 566. Reshape the Matrix</title>
      <link>https://www.maxlivinci.com/leetcode/2019-07-05-leetcode-566-reshape-the-matrix/</link>
      <pubDate>Fri, 05 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-07-05-leetcode-566-reshape-the-matrix/</guid>
      <description>LeetCode
Problem Statement In MATLAB, there is a very useful function called &amp;lsquo;reshape&amp;rsquo;, which can reshape a matrix into a new one with different size but keep its original data.
You&amp;rsquo;re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.
The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.</description>
    </item>
    
    <item>
      <title>LeetCode - 561. Array Partition I</title>
      <link>https://www.maxlivinci.com/leetcode/2019-07-04-leetcode-561-array-partition-i/</link>
      <pubDate>Thu, 04 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-07-04-leetcode-561-array-partition-i/</guid>
      <description>LeetCode
Problem Statement Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), &amp;hellip;, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.
Example:
Input: [1,4,3,2] Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).  Solution func arrayPairSum(nums []int) int { sort.</description>
    </item>
    
    <item>
      <title>LeetCode - 532. K-diff Pairs in an Array</title>
      <link>https://www.maxlivinci.com/leetcode/2019-07-03-leetcode-532-k-diff-pairs-in-an-array/</link>
      <pubDate>Wed, 03 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-07-03-leetcode-532-k-diff-pairs-in-an-array/</guid>
      <description>LeetCode
Problem Statement Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.
Example 1:
Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).</description>
    </item>
    
    <item>
      <title>LeetCode - 485. Max Consecutive Ones</title>
      <link>https://www.maxlivinci.com/leetcode/2019-07-02-leetcode-485-max-consecutive-ones/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-07-02-leetcode-485-max-consecutive-ones/</guid>
      <description> LeetCode
Problem Statement Given a binary array, find the maximum number of consecutive 1s in this array.
Example:
Given a binary array, find the maximum number of consecutive 1s in this array.  Solution func findMaxConsecutiveOnes(nums []int) int { max, counter := 0, 0 for _, v := range nums { if v == 1 { counter++ continue } if counter &amp;gt; max { max = counter } counter = 0 } if counter &amp;gt; max { max = counter } return max }  </description>
    </item>
    
    <item>
      <title>LeetCode - 448. Find All Numbers Disappeared in an Array</title>
      <link>https://www.maxlivinci.com/leetcode/2019-07-01-leetcode-448-find-all-numbers-disappeared-in-an-array/</link>
      <pubDate>Mon, 01 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-07-01-leetcode-448-find-all-numbers-disappeared-in-an-array/</guid>
      <description> LeetCode
Problem Statement Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.
Find all the elements of [1, n] inclusive that do not appear in this array.
Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.
Example:
Input: [4,3,2,7,8,2,3,1] Output: [5,6]  Solution func findDisappearedNumbers(nums []int) []int { for _, v := range nums { index := int(abs(v) - 1) if nums[index] &amp;gt; 0 { nums[index] = -nums[index] } } res := make([]int, 0, len(nums)) for i := 0; i &amp;lt; len(nums); i++ { if nums[i] &amp;gt; 0 { res = append(res, i+1) } } return res } func abs(x int) int { if x &amp;lt; 0 { return -x } return x }  </description>
    </item>
    
    <item>
      <title>LeetCode - 414. Third Maximum Number</title>
      <link>https://www.maxlivinci.com/leetcode/2019-06-30-leetcode-414-third-maximum-number/</link>
      <pubDate>Sun, 30 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-06-30-leetcode-414-third-maximum-number/</guid>
      <description>LeetCode
Problem Statement Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).
Example: 1
Input: [3, 2, 1] Output: 1  Example: 2
Input: [3, 2, 1] Output: 1  Example: 2
Input: [2, 2, 3, 1] Output: 1  Solution func thirdMax(nums []int) int { const INT_MAX = int(^uint(0) &amp;gt;&amp;gt; 1) const INT_MIN = ^INT_MAX s1, s2, s3 := INT_MIN, INT_MIN, INT_MIN for _, num := range nums { if num &amp;gt; s1 { s1, s2, s3 = num, s1, s2 } else if num &amp;lt; s1 &amp;amp;&amp;amp; num &amp;gt; s2 { s2, s3 = num, s2 } else if num &amp;lt; s2 &amp;amp;&amp;amp; num &amp;gt; s3 { s3 = num } } if s3 !</description>
    </item>
    
    <item>
      <title>LeetCode - 219. Contains Duplicate II</title>
      <link>https://www.maxlivinci.com/leetcode/2019-06-27-leetcode-219-contains-duplicate-ii/</link>
      <pubDate>Thu, 27 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-06-27-leetcode-219-contains-duplicate-ii/</guid>
      <description>LeetCode
Problem Statement Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.
Example: 1
Input: nums = [1,2,3,1], k = 3 Output: true  Example: 2
Input: nums = [1,0,1,1], k = 1 Output: true  Example: 3</description>
    </item>
    
    <item>
      <title>LeetCode - 217. Contains Duplicate</title>
      <link>https://www.maxlivinci.com/leetcode/2019-06-26-leetcode-217-contains-duplicate/</link>
      <pubDate>Wed, 26 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-06-26-leetcode-217-contains-duplicate/</guid>
      <description> LeetCode
Problem Statement Given an array of integers, find if the array contains any duplicates.
Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.
Example: 1
Input: [1,2,3,1] Output: true  Example: 2
Input: [1,2,3,4] Output: false  Example: 3
Input: [1,1,1,3,3,4,3,2,4,2] Output: true  Solution func containsDuplicate(nums []int) bool { hashMap := make(map[int]int) for _, v := range nums { _, ok := hashMap[v] if ok { return true } hashMap[v] = v } return false }  </description>
    </item>
    
    <item>
      <title>LeetCode - 236. Lowest Common Ancestor of a Binary Tree</title>
      <link>https://www.maxlivinci.com/leetcode/2019-06-23-leetcode-236-lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Sun, 23 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-06-23-leetcode-236-lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>LeetCode
Problem Statement Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4]</description>
    </item>
    
    <item>
      <title>LeetCode - 692. Top K Frequent Words</title>
      <link>https://www.maxlivinci.com/leetcode/2019-06-19-leetcode-692-top-k-frequent-words/</link>
      <pubDate>Wed, 19 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-06-19-leetcode-692-top-k-frequent-words/</guid>
      <description>LeetCode
Problem Statement Given a non-empty list of words, return the k most frequent elements.
Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.
Example: 1
Input: [&amp;quot;i&amp;quot;, &amp;quot;love&amp;quot;, &amp;quot;leetcode&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;love&amp;quot;, &amp;quot;coding&amp;quot;], k = 2 Output: [&amp;quot;i&amp;quot;, &amp;quot;love&amp;quot;] Explanation: &amp;quot;i&amp;quot; and &amp;quot;love&amp;quot; are the two most frequent words. Note that &amp;quot;i&amp;quot; comes before &amp;quot;love&amp;quot; due to a lower alphabetical order.</description>
    </item>
    
    <item>
      <title>LeetCode - 003. Longest Substring Without Repeating Characters</title>
      <link>https://www.maxlivinci.com/leetcode/2019-06-18-leetcode-003-longest-substring-without-repeating-characters/</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-06-18-leetcode-003-longest-substring-without-repeating-characters/</guid>
      <description>LeetCode
Problem Statement Given a string, find the length of the longest substring without repeating characters.
Example: 1
Input: &amp;quot;abcabcbb&amp;quot; Output: 3 Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3.  Example: 2
Input: &amp;quot;bbbbb&amp;quot; Output: 1 Explanation: The answer is &amp;quot;b&amp;quot;, with the length of 1.  Example: 3
Input: &amp;quot;pwwkew&amp;quot; Output: 3 Explanation: The answer is &amp;quot;wke&amp;quot;, with the length of 3. Note that the answer must be a substring, &amp;quot;pwke&amp;quot; is a subsequence and not a substring.</description>
    </item>
    
    <item>
      <title>LeetCode - 119. Pascal&#39;s Triangle - II</title>
      <link>https://www.maxlivinci.com/leetcode/2019-06-17-leetcode-119-pascals-triangle-ii/</link>
      <pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-06-17-leetcode-119-pascals-triangle-ii/</guid>
      <description> LeetCode
Problem Statement Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal&amp;rsquo;s triangle.
Note that the row index starts from 0.
Example:
Input: 3 Output: [1,3,3,1]  Solution func getRow(rowIndex int) []int { result := make([][]int, rowIndex+1) result[0] = []int{1} for row := 1; row &amp;lt;= rowIndex; row++ { result[row] = make([]int, row+1) for column := 0; column &amp;lt;= row; column++ { if column == 0 || column == row { result[row][column] = 1 } else { result[row][column] = result[row-1][column-1] + result[row-1][column] } } } return result[rowIndex] }  </description>
    </item>
    
    <item>
      <title>LeetCode - 066. Plus One</title>
      <link>https://www.maxlivinci.com/leetcode/2019-06-15-leetcode-066-plus-one/</link>
      <pubDate>Sat, 15 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-06-15-leetcode-066-plus-one/</guid>
      <description>Plus One
Problem Statement Given a non-empty array of digits representing a non-negative integer, plus one to the integer.
The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.
You may assume the integer does not contain any leading zero, except the number 0 itself.
Example 1:
Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.</description>
    </item>
    
    <item>
      <title>LeetCode - 027. Remove Element</title>
      <link>https://www.maxlivinci.com/leetcode/2019-06-13-leetcode-027-remove-element/</link>
      <pubDate>Thu, 13 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-06-13-leetcode-027-remove-element/</guid>
      <description>LeetCode
Problem Statement Given an array nums and a value val, remove all instances of that value in-place and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
The order of elements can be changed. It doesn&amp;rsquo;t matter what you leave beyond the new length.
Example 1:
Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2.</description>
    </item>
    
    <item>
      <title>LeetCode - 938. Range Sum of BST</title>
      <link>https://www.maxlivinci.com/leetcode/2019-06-09-leetcode-938-range-sum-of-bst/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-06-09-leetcode-938-range-sum-of-bst/</guid>
      <description>LeetCode
Problem Statement Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive).
The binary search tree is guaranteed to have unique values.
Example 1:
Input: root = [10,5,15,3,7,null,18], L = 7, R = 15 Output: 32  Example 2:
Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 Output: 23  Solution /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>LeetCode - 257. Binary Tree Paths</title>
      <link>https://www.maxlivinci.com/leetcode/2019-06-08-leetcode-257-binary-tree-paths/</link>
      <pubDate>Sat, 08 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-06-08-leetcode-257-binary-tree-paths/</guid>
      <description>LeetCode
Problem Statement Given a binary tree, return all root-to-leaf paths.
Note: A leaf is a node with no children.
Example:
Input: 1 / \ 2 3 \ 5 Output: [&amp;quot;1-&amp;gt;2-&amp;gt;5&amp;quot;, &amp;quot;1-&amp;gt;3&amp;quot;] Explanation: All root-to-leaf paths are: 1-&amp;gt;2-&amp;gt;5, 1-&amp;gt;3  Solution /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ import &amp;quot;strconv&amp;quot; func binaryTreePaths(root *TreeNode) []string { if root == nil { return nil } res := make([]string, 0, 16) dfs(&amp;quot;&amp;quot;, root, &amp;amp;res) return res } func dfs(path string, root *TreeNode, res *[]string) { if path == &amp;quot;&amp;quot; { path += strconv.</description>
    </item>
    
    <item>
      <title>LeetCode - 104. Maximum Depth of Binary Tree</title>
      <link>https://www.maxlivinci.com/leetcode/2019-06-07-leetcode-104-maximum-depth-of-binary-tree/</link>
      <pubDate>Fri, 07 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-06-07-leetcode-104-maximum-depth-of-binary-tree/</guid>
      <description>LeetCode
Problem Statement Given a binary tree, find its maximum depth.
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
Note: A leaf is a node with no children.
Example:
Given binary tree [3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7  return its depth = 3.
Solution /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>LeetCode - 049. Group Anagrams</title>
      <link>https://www.maxlivinci.com/leetcode/2019-06-05-leetcode-049-group-anagrams/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-06-05-leetcode-049-group-anagrams/</guid>
      <description> LeetCode
Problem Statement Given an array of strings, group anagrams together.
Example:
Input: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;], Output: [ [&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;], [&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;], [&amp;quot;bat&amp;quot;] ]  Solution import ( &amp;quot;sort&amp;quot; &amp;quot;strings&amp;quot; ) func SortString(w string) string { s := strings.Split(w, &amp;quot;&amp;quot;) sort.Strings(s) return strings.Join(s, &amp;quot;&amp;quot;) } func groupAnagrams(strs []string) [][]string { m := make(map[string][]string) for _, w := range strs { word := SortString(w) m[word] = append(m[word], w) } var ss [][]string for e := range m { ss = append(ss, m[e]) } return ss }  </description>
    </item>
    
    <item>
      <title>LeetCode - 242. Valid Anagram</title>
      <link>https://www.maxlivinci.com/leetcode/2019-06-04-leetcode-242-valid-anagram/</link>
      <pubDate>Tue, 04 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-06-04-leetcode-242-valid-anagram/</guid>
      <description>LeetCode
Problem Statement Given two strings s and t , write a function to determine if t is an anagram of s.
Example 1:
 Input: s = &amp;ldquo;anagram&amp;rdquo;, t = &amp;ldquo;nagaram&amp;rdquo;
Output: true
 Example 2:
 Input: s = &amp;ldquo;rat&amp;rdquo;, t = &amp;ldquo;car&amp;rdquo;
Output: false
 Solution func isAnagram(s string, t string) bool { if len(s) != len(t) { return false } mapA := buildCharMap(s) mapB := buildCharMap(t) for key, Acount := range mapA { Bcount, ok := mapB[key] if !</description>
    </item>
    
    <item>
      <title>LeetCode - 024. Swap Nodes in Pairs</title>
      <link>https://www.maxlivinci.com/leetcode/2019-06-03-leetcode-024-swap-nodes-in-pairs/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-06-03-leetcode-024-swap-nodes-in-pairs/</guid>
      <description>LeetCode
Problem Statement Given a linked list, swap every two adjacent nodes and return its head.
You may not modify the values in the list&amp;rsquo;s nodes, only nodes itself may be changed.
Example
 Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, you should return the list as 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.
 Solution /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func swapPairs(head *ListNode) *ListNode { dummy := ListNode{} dummy.</description>
    </item>
    
    <item>
      <title>LeetCode - 189. Rotate Array</title>
      <link>https://www.maxlivinci.com/leetcode/2019-05-31-leetcode-189-rotate-array/</link>
      <pubDate>Fri, 31 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-05-31-leetcode-189-rotate-array/</guid>
      <description>LeetCode
Problem Statement Given an array, rotate the array to the right by k steps, where k is non-negative.
Example 1
 Input: [1,2,3,4,5,6,7] and k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
 Example 2
 Input: [-1,-100,3,99] and k = 2
Output: [3,99,-1,-100]
Explanation:
rotate 1 steps to the right: [99,-1,-100,3]</description>
    </item>
    
    <item>
      <title>LeetCode - 026. Remove Duplicates from Sorted Array</title>
      <link>https://www.maxlivinci.com/leetcode/2019-05-30-leetcode-026-remove-duplicates-from-sorted-array/</link>
      <pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/leetcode/2019-05-30-leetcode-026-remove-duplicates-from-sorted-array/</guid>
      <description>LeetCode
Problem Statement Given a sorted array of numbers, remove the duplicates in-place such that each element appear only once and return the new length.
Example 1
 Given nums = [1,1,2],
Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.
It doesn’t matter what you leave beyond the returned length.
 Example 2
 Given nums = [0,0,1,1,1,2,2,3,3,4],</description>
    </item>
    
  </channel>
</rss>