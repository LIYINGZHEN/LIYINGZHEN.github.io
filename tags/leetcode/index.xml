<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on YING ZHEN LI</title>
    <link>https://www.maxlivinci.com/tags/leetcode/</link>
    <description>Recent content in Leetcode on YING ZHEN LI</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 12 Jun 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.maxlivinci.com/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LeetCode - 053. Maximum Subarray</title>
      <link>https://www.maxlivinci.com/blog/2019-06-12-leetcode-053-maximum-subarray/</link>
      <pubDate>Wed, 12 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-06-12-leetcode-053-maximum-subarray/</guid>
      <description> LeetCode
Problem Statement Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.
Example:
Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) Output: 7 -&amp;gt; 0 -&amp;gt; 8 Explanation: 342 + 465 = 807.  Solution func maxSubArray(nums []int) int { cur, max := nums[0], nums[0] for _, v := range(nums[1:]) { if cur &amp;lt; 0 { cur = v } else { cur += v } if cur &amp;gt; max { max = cur } } return max }  </description>
    </item>
    
    <item>
      <title>LeetCode - 002. Add Two Numbers</title>
      <link>https://www.maxlivinci.com/blog/2019-06-11-leetcode-002-add-two-numbers/</link>
      <pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-06-11-leetcode-002-add-two-numbers/</guid>
      <description>LeetCode
Problem Statement You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example:
Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) Output: 7 -&amp;gt; 0 -&amp;gt; 8 Explanation: 342 + 465 = 807.</description>
    </item>
    
    <item>
      <title>LeetCode - 001. Two Sum</title>
      <link>https://www.maxlivinci.com/blog/2019-06-10-leetcode-001-two-sum/</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-06-10-leetcode-001-two-sum/</guid>
      <description> LeetCode
Problem Statement Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
Example:
Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].  Solution func twoSum(nums []int, target int) []int { // visited store value and index visited := make(map[int]int) for currentIndex, v := range nums { counterPart := target - v counterPartIndex, ok := visited[counterPart] if ok { return []int{counterPartIndex, currentIndex} } visited[v] = currentIndex } return []int{-1, -1} }  </description>
    </item>
    
    <item>
      <title>LeetCode - 938. Range Sum of BST</title>
      <link>https://www.maxlivinci.com/blog/2019-06-09-leetcode-938-range-sum-of-bst/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-06-09-leetcode-938-range-sum-of-bst/</guid>
      <description>LeetCode
Problem Statement Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive).
The binary search tree is guaranteed to have unique values.
Example 1:
Input: root = [10,5,15,3,7,null,18], L = 7, R = 15 Output: 32  Example 2:
Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 Output: 23  Solution /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>LeetCode - 257. Binary Tree Paths</title>
      <link>https://www.maxlivinci.com/blog/2019-06-08-leetcode-257-binary-tree-paths/</link>
      <pubDate>Sat, 08 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-06-08-leetcode-257-binary-tree-paths/</guid>
      <description>LeetCode
Problem Statement Given a binary tree, return all root-to-leaf paths.
Note: A leaf is a node with no children.
Example:
Input: 1 / \ 2 3 \ 5 Output: [&amp;quot;1-&amp;gt;2-&amp;gt;5&amp;quot;, &amp;quot;1-&amp;gt;3&amp;quot;] Explanation: All root-to-leaf paths are: 1-&amp;gt;2-&amp;gt;5, 1-&amp;gt;3  Solution /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ import &amp;quot;strconv&amp;quot; func binaryTreePaths(root *TreeNode) []string { if root == nil { return nil } res := make([]string, 0, 16) dfs(&amp;quot;&amp;quot;, root, &amp;amp;res) return res } func dfs(path string, root *TreeNode, res *[]string) { if path == &amp;quot;&amp;quot; { path += strconv.</description>
    </item>
    
    <item>
      <title>LeetCode - 104. Maximum Depth of Binary Tree</title>
      <link>https://www.maxlivinci.com/blog/2019-06-07-leetcode-104-maximum-depth-of-binary-tree/</link>
      <pubDate>Fri, 07 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-06-07-leetcode-104-maximum-depth-of-binary-tree/</guid>
      <description>LeetCode
Problem Statement Given a binary tree, find its maximum depth.
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
Note: A leaf is a node with no children.
Example:
Given binary tree [3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7  return its depth = 3.
Solution /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>LeetCode - 50. Pow(x, n)</title>
      <link>https://www.maxlivinci.com/blog/2019-06-06-leetcode-050-pow/</link>
      <pubDate>Thu, 06 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-06-06-leetcode-050-pow/</guid>
      <description> LeetCode
Problem Statement Implement pow(x, n), which calculates x raised to the power n (xn).
Example 1:
Input: 2.00000, 10 Output: 1024.00000  Example 2:
Input: 2.10000, 3 Output: 9.26100  Example 3:
Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25  Solution func myPow(x float64, n int) float64 { if n == 0 { return 1 } if n == 1 { return x } if n &amp;lt; 0 { return 1 / myPow(x, -n) } if n%2 == 0 { return myPow(x*x, n/2) } else { return x * myPow(x*x, n/2) } }  </description>
    </item>
    
    <item>
      <title>LeetCode - 049. Group Anagrams</title>
      <link>https://www.maxlivinci.com/blog/2019-06-05-leetcode-049-group-anagrams/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-06-05-leetcode-049-group-anagrams/</guid>
      <description> LeetCode
Problem Statement Given an array of strings, group anagrams together.
Example:
Input: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;], Output: [ [&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;], [&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;], [&amp;quot;bat&amp;quot;] ]  Solution import ( &amp;quot;sort&amp;quot; &amp;quot;strings&amp;quot; ) func SortString(w string) string { s := strings.Split(w, &amp;quot;&amp;quot;) sort.Strings(s) return strings.Join(s, &amp;quot;&amp;quot;) } func groupAnagrams(strs []string) [][]string { m := make(map[string][]string) for _, w := range strs { word := SortString(w) m[word] = append(m[word], w) } var ss [][]string for e := range m { ss = append(ss, m[e]) } return ss }  </description>
    </item>
    
    <item>
      <title>LeetCode - 242. Valid Anagram</title>
      <link>https://www.maxlivinci.com/blog/2019-06-04-leetcode-242-valid-anagram/</link>
      <pubDate>Tue, 04 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-06-04-leetcode-242-valid-anagram/</guid>
      <description>LeetCode
Problem Statement Given two strings s and t , write a function to determine if t is an anagram of s.
Example 1:
 Input: s = &amp;ldquo;anagram&amp;rdquo;, t = &amp;ldquo;nagaram&amp;rdquo;
Output: true
 Example 2:
 Input: s = &amp;ldquo;rat&amp;rdquo;, t = &amp;ldquo;car&amp;rdquo;
Output: false
 Solution func isAnagram(s string, t string) bool { if len(s) != len(t) { return false } mapA := buildCharMap(s) mapB := buildCharMap(t) for key, Acount := range mapA { Bcount, ok := mapB[key] if !</description>
    </item>
    
    <item>
      <title>LeetCode - 024. Swap Nodes in Pairs</title>
      <link>https://www.maxlivinci.com/blog/2019-06-03-leetcode-024-swap-nodes-in-pairs/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-06-03-leetcode-024-swap-nodes-in-pairs/</guid>
      <description>LeetCode
Problem Statement Given a linked list, swap every two adjacent nodes and return its head.
You may not modify the values in the list&amp;rsquo;s nodes, only nodes itself may be changed.
Example
 Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, you should return the list as 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.
 Solution /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func swapPairs(head *ListNode) *ListNode { dummy := ListNode{} dummy.</description>
    </item>
    
    <item>
      <title>LeetCode - 088. Merge Sorted Array</title>
      <link>https://www.maxlivinci.com/blog/2019-06-02-leetcode-088-merge-sorted-array/</link>
      <pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-06-02-leetcode-088-merge-sorted-array/</guid>
      <description>LeetCode
Problem Statement Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.
Note:
 The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.  Example
 Input:
nums1 = [1,2,3,0,0,0], m = 3</description>
    </item>
    
    <item>
      <title>LeetCode - 021. Merge Two Sorted Lists</title>
      <link>https://www.maxlivinci.com/blog/2019-06-01-leetcode-021-merge-two-sorted-lists/</link>
      <pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-06-01-leetcode-021-merge-two-sorted-lists/</guid>
      <description>LeetCode
Problem Statement Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
Example
 Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4
Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4
 Solution /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { // Check boundary condition if l1 == nil { return l2 } if l2 == nil { return l1 } // Create dummy node dummy := ListNode{} head := &amp;amp;dummy // Connect l1 and l2 for l1 !</description>
    </item>
    
    <item>
      <title>LeetCode - 189. Rotate Array</title>
      <link>https://www.maxlivinci.com/blog/2019-05-31-leetcode-189-rotate-array/</link>
      <pubDate>Fri, 31 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-31-leetcode-189-rotate-array/</guid>
      <description>LeetCode
Problem Statement Given an array, rotate the array to the right by k steps, where k is non-negative.
Example 1
 Input: [1,2,3,4,5,6,7] and k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
 Example 2
 Input: [-1,-100,3,99] and k = 2
Output: [3,99,-1,-100]
Explanation:
rotate 1 steps to the right: [99,-1,-100,3]</description>
    </item>
    
    <item>
      <title>LeetCode - 026. Remove Duplicates from Sorted Array</title>
      <link>https://www.maxlivinci.com/blog/2019-05-30-leetcode-026-remove-duplicates-from-sorted-array/</link>
      <pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/blog/2019-05-30-leetcode-026-remove-duplicates-from-sorted-array/</guid>
      <description>LeetCode
Problem Statement Given a sorted array of numbers, remove the duplicates in-place such that each element appear only once and return the new length.
Example 1
 Given nums = [1,1,2],
Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.
It doesn’t matter what you leave beyond the returned length.
 Example 2
 Given nums = [0,0,1,1,1,2,2,3,3,4],</description>
    </item>
    
  </channel>
</rss>