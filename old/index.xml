<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Olds on YING ZHEN LI</title>
    <link>https://www.maxlivinci.com/old/</link>
    <description>Recent content in Olds on YING ZHEN LI</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 14 Mar 2019 07:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.maxlivinci.com/old/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Linux</title>
      <link>https://www.maxlivinci.com/old/2019-03-14-linux/</link>
      <pubDate>Thu, 14 Mar 2019 07:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-03-14-linux/</guid>
      <description>Commands ls -l # Changes the working directory to your home directory. cd # Changes the working directory to the previous working directory. cd - # i - interactive # v - verbose cp -iv /etc/passwd . # i - interactive # r - recursive rm -ir fun </description>
    </item>
    
    <item>
      <title>Redis</title>
      <link>https://www.maxlivinci.com/old/2019-03-13-redis/</link>
      <pubDate>Wed, 13 Mar 2019 06:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-03-13-redis/</guid>
      <description>Commands redis-cli # Local redis-cli -h host -p port -a password # Run Commands on the Remote Server redis-cli INFO memory Data Types  Strings Lists Hashes Sets Sorted Sets  Strings # SET first &amp;#34;First Key value&amp;#34; GET first # EXPIRE command adds an expiration time (in seconds) to a given key. EXPIRE first 10 # TTL (Time To Live) command returns the amount of seconds a given key has left to live.</description>
    </item>
    
    <item>
      <title>MongoDB</title>
      <link>https://www.maxlivinci.com/old/2019-03-09-mongodb/</link>
      <pubDate>Sun, 10 Mar 2019 16:00:00 +0000</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-03-09-mongodb/</guid>
      <description>Indexing and query optimization  Indexes in MongoDB are very important. Indexes that use more than one key like this are called compound indexes. The order of keys in a compound index matters. Aa query where one term demands an exact match and another specifies a range requires a compound index where the range key comes second.  For example:
If we have this query, then the manufacturer shoud be the first index.</description>
    </item>
    
    <item>
      <title>OpenAPI Specification</title>
      <link>https://www.maxlivinci.com/old/2019-01-26-open-api-specification/</link>
      <pubDate>Sat, 26 Jan 2019 18:40:48 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-26-open-api-specification/</guid>
      <description>OpenAPI lets us define RESTful APIs in a standardized manner, and they can be defined without being tied down to any particular programming language or framework being used.
Let&amp;rsquo;s list the general structure of an OpenAPI specification and use it to redefine the Books API described in Chapter 4, The RESTful Web.
If we look at the Books API title, we can define the following elements to describe the API:</description>
    </item>
    
    <item>
      <title>Go Environment</title>
      <link>https://www.maxlivinci.com/old/2019-01-26-go-environment/</link>
      <pubDate>Sat, 26 Jan 2019 11:20:00 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-26-go-environment/</guid>
      <description>GOROOT To access to the Go binary and its libraries
GOPATH To tell the Go compiler where to find the source code for the project and its dependencies.
src/ Contain the source code of our projects and their dependencies.
pkg/ To store reusable machine code that can be readily included in our Go binary.
bin/ Go compiles and builds our projects into executable binaries and places them in this directory.</description>
    </item>
    
    <item>
      <title>Worker pools</title>
      <link>https://www.maxlivinci.com/old/2019-01-26-worker-pools/</link>
      <pubDate>Sat, 26 Jan 2019 09:52:00 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-26-worker-pools/</guid>
      <description>A worker pool is a set of threads that are about to process jobs assigned to them.  Example package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;strconv&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) type Client struct { id int integer int } type Data struct { job Client square int } var ( size = 10 clients = make(chan Client, size) data = make(chan Data, size) ) func worker(w *sync.WaitGroup) { for c := range clients { square := c.</description>
    </item>
    
    <item>
      <title>Concurrency and parallelism</title>
      <link>https://www.maxlivinci.com/old/2019-01-25-concurrency-and-parallelism/</link>
      <pubDate>Fri, 25 Jan 2019 21:08:00 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-25-concurrency-and-parallelism/</guid>
      <description>Computer and software programs are useful because they do a lot of laborious work very fast and can also do multiple things at once. We want our programs to be able to do multiple things simultaneously, that is, multitask, and the success of a programming language can depend on how easy it is to write and understand multitasking programs.
Concurrency and parallelism are two terms that we are bound to come across often when looking into multitasking and they are often used interchangeably.</description>
    </item>
    
    <item>
      <title>General Go coding advices</title>
      <link>https://www.maxlivinci.com/old/2019-01-19-general-go-coding-advices/</link>
      <pubDate>Sat, 19 Jan 2019 17:05:00 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-19-general-go-coding-advices/</guid>
      <description>The following list offers practical advices that will help you write better Go code:
 If you have an error in a Go function, either log it or return it, do not do both unless you have a really good reason for doing so! Go interfaces define behaviors, not data and data structures. Use the io.Reader and io.Writer interfaces because they make your code more extensible. Make sure that you pass a pointer to a variable of a function only when needed.</description>
    </item>
    
    <item>
      <title>Find out Go Environment</title>
      <link>https://www.maxlivinci.com/old/2019-01-19-find-out-go-environment/</link>
      <pubDate>Sat, 19 Jan 2019 17:02:00 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-19-find-out-go-environment/</guid>
      <description>package main import ( &amp;#34;fmt&amp;#34; &amp;#34;runtime&amp;#34; ) func main() { fmt.Print(&amp;#34;You are using &amp;#34;, runtime.Compiler, &amp;#34; &amp;#34;) fmt.Println(&amp;#34;on a&amp;#34;, runtime.GOARCH, &amp;#34;machine&amp;#34;) fmt.Println(&amp;#34;Using Go version&amp;#34;, runtime.Version()) fmt.Println(&amp;#34;Number of CPUs:&amp;#34;, runtime.NumCPU()) fmt.Println(&amp;#34;Number of Goroutines:&amp;#34;, runtime.NumGoroutine()) } xecuting goEnv.go on a macOS High Sierra machine with Go version 1.9.2 will create the following output:
$ go run goEnv.go You are using gc on a amd64 machine Using Go version go1.9.2 Number of CPUs: 8 Number of Goroutines: 1 </description>
    </item>
    
    <item>
      <title>Writing to log files</title>
      <link>https://www.maxlivinci.com/old/2019-01-19-writing-to-log-files/</link>
      <pubDate>Sat, 19 Jan 2019 15:44:00 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-19-writing-to-log-files/</guid>
      <description>Generally speaking, using a log file to write some information is considered a better practice than writing the same output on the screen for two reasons:
  The output does not get lost as it is stored in a file
  You can search and process log files using Unix tools such as grep(1), awk(1), and sed(1), which cannot be done when messages are printed on a Terminal window</description>
    </item>
    
    <item>
      <title>An Example of Using RabbitMQ From Go</title>
      <link>https://www.maxlivinci.com/old/2019-01-19-an-example-of-using-rabbitmq-from-go/</link>
      <pubDate>Sat, 19 Jan 2019 07:42:05 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-19-an-example-of-using-rabbitmq-from-go/</guid>
      <description>Sending We&amp;rsquo;ll call our message publisher (sender) send.go and our message consumer (receiver) receive.go. The publisher will connect to RabbitMQ, send a single message, then exit.
package main import ( &amp;#34;log&amp;#34; &amp;#34;github.com/streadway/amqp&amp;#34; ) func failOnError(err error, msg string) { if err != nil { log.Fatalf(&amp;#34;%s: %s&amp;#34;, msg, err) } } func main() { conn, err := amqp.Dial(&amp;#34;amqp://guest:guest@localhost:5672/&amp;#34;) failOnError(err, &amp;#34;Failed to connect to RabbitMQ&amp;#34;) defer conn.Close() ch, err := conn.Channel() failOnError(err, &amp;#34;Failed to open a channel&amp;#34;) defer ch.</description>
    </item>
    
    <item>
      <title>CQRS</title>
      <link>https://www.maxlivinci.com/old/2019-01-19-cqrs/</link>
      <pubDate>Sat, 19 Jan 2019 07:00:00 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-19-cqrs/</guid>
      <description>Introducing Command Query Responsibility Segregation CQRS is a fancy pattern name that means decoupling the input and the output of your system.</description>
    </item>
    
    <item>
      <title>Event-Driven Architecture</title>
      <link>https://www.maxlivinci.com/old/2019-01-13-event-driven-architecture/</link>
      <pubDate>Sun, 13 Jan 2019 13:44:00 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-13-event-driven-architecture/</guid>
      <description>Asynchronous processing With asynchronous processing, all the communication to the downstream application happens out of process leveraging a queue or a message broker as an intermediary.</description>
    </item>
    
    <item>
      <title>Serving Static Files In Go</title>
      <link>https://www.maxlivinci.com/old/2019-01-12-servering-static-files/</link>
      <pubDate>Sat, 12 Jan 2019 17:15:17 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-12-servering-static-files/</guid>
      <description>func main() { port := 8080 cathandler := http.FileServer(http.Dir(&amp;#34;./images&amp;#34;)) // images/...  http.Handle(&amp;#34;/cat/&amp;#34;, http.StripPrefix(&amp;#34;/cat/&amp;#34;, cathandler)) // images/cat/...  http.Handle(&amp;#34;/cat/&amp;#34;, cathandler) log.Printf(&amp;#34;Server starting on port %v\n&amp;#34;, 8080) log.Fatal(http.ListenAndServe(fmt.Sprintf(&amp;#34;:%v&amp;#34;, port), nil)) } </description>
    </item>
    
    <item>
      <title>An Example of Using Nsq From Go</title>
      <link>https://www.maxlivinci.com/old/2019-01-11-an-example-of-using-nsq-from-go/</link>
      <pubDate>Fri, 11 Jan 2019 10:27:05 +0100</pubDate>
      
      <guid>https://www.maxlivinci.com/old/2019-01-11-an-example-of-using-nsq-from-go/</guid>
      <description>NSQ is a message queue, similar to RabbitMQ. I decided I’d give it a whirl.
 Install Nsq brew install nsq Launch Nsq nsqlookupd &amp;amp; nsqd --lookupd-tcp-address=127.0.0.1:4160 &amp;amp; nsqadmin --lookupd-http-address=127.0.0.1:4161 &amp;amp; Get Go client library go get github.com/nsqio/go-nsq Create a producer package main import ( &amp;#34;log&amp;#34; &amp;#34;github.com/bitly/go-nsq&amp;#34; ) func main() { config := nsq.NewConfig() w, _ := nsq.NewProducer(&amp;#34;127.0.0.1:4150&amp;#34;, config) err := w.Publish(&amp;#34;write_test&amp;#34;, []byte(&amp;#34;test&amp;#34;)) if err != nil { log.Panic(&amp;#34;Could not connect&amp;#34;) } w.</description>
    </item>
    
  </channel>
</rss>